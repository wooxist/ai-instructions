# 핵심 설계 원칙

> 이 문서는 메타 에이전트가 아키텍트 및 워커 에이전트를 설계할 때 반드시 따라야 할 핵심 원칙을 정리합니다.

## 1. 기본 개념

### 1.1 인스트럭션 vs 프롬프트

- **프롬프트**: 일회성 질문, 즉흥적, 재사용 어려움
- **인스트럭션**: 재사용 가능한 표준화된 지시 체계, 버전 관리 가능, 팀 협업 가능

### 1.2 에이전트란?

**에이전트**는 특정 역할, 책임, 제약 조건을 가진 독립적인 실행 단위입니다.
- **역할(Role)**: 에이전트가 수행하는 전문 분야 (예: "10년차 데이터 분석가")
- **책임(Responsibility)**: 에이전트가 달성해야 할 구체적인 목표
- **제약(Constraints)**: 에이전트가 반드시 지켜야 할 규칙과 한계

### 1.3 에이전트의 계층 구조

```
메타 에이전트 (Meta Agent)
  ↓ 전략적 의사결정, 시스템 총괄
아키텍트 에이전트 (Architect Agent)  
  ↓ 워크플로우 설계, 워커 관리
워커 에이전트 (Worker Agent)
  ↓ 구체적인 작업 실행
```

## 2. 메타 원칙

### 2.1 구조적 원칙

#### SSOT (Single Source of Truth)
**정의**: 핵심 정의·템플릿을 단일 출처에서 관리하고 중복 제거

**적용 방법**:
- 공통 출력 스키마를 별도 파일로 분리 (예: `schemas/common.json`)
- 에이전트의 지식 출처를 명시적으로 한정 (특정 문서, 데이터베이스만 참조)

**예시**:
```yaml
# 나쁜 예: 각 에이전트마다 출력 스키마 중복 정의
# 좋은 예: 공통 스키마 참조
agents/worker1.md:
  output_schema: schemas/report.schema.json
agents/worker2.md:
  output_schema: schemas/report.schema.json
```

#### SoC (Separation of Concerns)
**정의**: 각 부분이 하나의 책임만 갖도록 분리

**적용 방법**:
- '역할 정의', '처리 방법', '출력 형식'을 별도 섹션으로 분리
- 코드 생성 에이전트 ≠ 코드 리뷰 에이전트

**예시**:
```markdown
# 나쁜 예: 하나의 에이전트가 코드 생성과 리뷰를 모두 담당
# 좋은 예: 
agents/code-generator.md  # 코드 생성만 담당
agents/code-reviewer.md   # 코드 리뷰만 담당
```

#### MECE (Mutually Exclusive, Collectively Exhaustive)
**정의**: 중복 없이, 빠짐없이 구성

**적용 방법**:
- 고객 리뷰를 '제품', '배송', 'CS' 카테고리로 중복 없이 분류
- 워커 에이전트들의 역할이 서로 겹치지 않도록 설계

**예시**:
```yaml
# 좋은 예: MECE 원칙을 따른 역할 분담
agents:
  - name: product-reviewer
    scope: 제품 품질 관련 리뷰만 처리
  - name: delivery-reviewer  
    scope: 배송 관련 리뷰만 처리
  - name: cs-reviewer
    scope: 고객 서비스 관련 리뷰만 처리
```

#### 원자성 (Atomicity)
**정의**: 각 작업을 더 이상 나눌 수 없는 최소 단위로 구성

**적용 방법**:
- "보고서 작성"을 "데이터 추출 → 분석 → 초안 작성"으로 분리
- 각 단계의 성공/실패를 명확히 판단 가능하게

**예시**:
```yaml
# 나쁜 예: 하나의 복잡한 태스크
- task: "사용자 정보를 조회하고 처리하라"

# 좋은 예: 원자적 태스크들
- task: "사용자 ID 유효성 검증"
- task: "데이터베이스에서 사용자 정보 조회"
- task: "조회된 정보를 JSON 형식으로 포맷팅"
```

### 2.2 실행 원칙

#### 산출물 중심 (Output-Driven)
**정의**: 과정보다 최종 결과물의 요건을 먼저 명확히 정의

**적용 방법**:
- 출력 형식을 JSON Schema로 명시
- "충분히 자세히" 대신 "필수 필드 3개를 포함하는 JSON 형식"

**예시**:
```json
{
  "output_schema": {
    "type": "object",
    "properties": {
      "summary": {"type": "string", "maxLength": 500},
      "key_points": {
        "type": "array",
        "items": {"type": "string"},
        "minItems": 3,
        "maxItems": 5
      }
    },
    "required": ["summary", "key_points"]
  }
}
```

#### 피드백 루프 (Feedback Loop)
**정의**: 작업 전 의도를 명확히 하고, 작업 후 결과를 검증하는 순환 과정

**적용 방법**:
- **의도 확인**: 모호한 지시를 받으면 실행 전 질문하도록 지시
- **자기 검증**: 결과물 생성 후 요구사항 충족 여부 스스로 확인

**예시**:
```markdown
# 워커 에이전트 인스트럭션에 포함할 내용
## 제약 조건
- 입력이 모호하면 실행 전 사용자에게 명확히 질문할 것
- 작업 완료 후 다음 체크리스트로 자체 검증:
  * [ ] 모든 필수 필드가 포함되었는가?
  * [ ] 출력 형식이 스키마를 준수하는가?
  * [ ] 제약 조건을 모두 지켰는가?
```

#### 점진적 개선 (Iterative Refinement)
**정의**: 초안→피드백→개선의 짧은 주기를 반복

**적용 방법**:
- 완벽한 첫 결과물보다 빠른 초안 생성
- 3회 정도의 수정 주기로 품질 향상

#### 컨텍스트 명시성 (Context Explicitness)
**정의**: 필요한 모든 정보를 명시적으로 제공, AI가 추측하지 않도록

**적용 방법**:
```markdown
# 좋은 예
## 컨텍스트
- 대상 독자: 개발 경험이 없는 기획자
- 목적: 의사결정 지원
- 분량: A4 2페이지 이내
```

### 2.3 검증 및 책임 원칙

#### 투명성·추적성 (Transparency & Traceability)
**정의**: 모든 결정과 결과물의 근거를 명확히 기록

**적용 방법**:
```markdown
## 제약 조건
- 모든 주장의 근거가 된 문서명과 페이지를 함께 인용할 것
- 버전 관리: 모든 변경사항 기록
```

#### 윤리적 경계 (Ethical Boundaries)
**정의**: 개인정보·저작권 등 경계를 명확히 하고 최소 권한만 부여

**적용 방법**:
```markdown
## 제약 조건
- 절대 개인 식별 정보(PII)를 출력에 포함하지 말 것
- 민감한 정보(연봉, 평가 등) 질문에는 답변 거부
```

#### Human-in-the-Loop
**정의**: 중요 의사결정에 사람의 검토를 포함

**적용 방법**:
```yaml
workflow:
  - step: generate_draft
  - step: human_approval  # 중요한 단계
    type: approval
    description: "최종 이메일 발송 전 사용자 승인 필수"
  - step: send_email
```

## 3. 인스트럭션 8가지 핵심 구성 요소

모든 에이전트 인스트럭션은 다음 구조를 따라야 합니다:

```markdown
# [에이전트 이름]

## 1. 목적 (Purpose)
이 에이전트의 최종 목표를 한 문장으로 정의

## 2. 역할 (Role)
어떤 전문가 역할을 수행하는지 (예: "10년차 마케터")

## 3. 입력 (Input)
처리할 데이터의 형식, 구조, 출처

## 4. 처리 방법 (Process)
작업 수행 절차를 단계별로 지시

## 5. 출력 (Output)
결과물의 형식과 내용 (JSON Schema 등)

## 6. 제약 조건 (Constraints)
반드시 지켜야 할 한계와 금지사항

## 7. 평가 기준 (Evaluation)
결과물의 품질을 판단하는 검증 가능한 기준

## 8. 기초 지식 (Principles)
항상 참고해야 할 기본 원칙이나 배경지식
```

## 4. 에이전트 유형별 필수 원칙 매트릭스

### 워커 에이전트 (단일 작업)
**필수 원칙**: 
- 산출물 중심 (명확한 출력 정의)
- 원자성 (단일 책임)
- 컨텍스트 명시성

**예시 구조**:
```markdown
# 데이터 추출 워커

## 목적
CSV 파일에서 특정 컬럼 데이터만 추출

## 역할  
데이터 처리 전문가

## 입력
- CSV 파일 경로
- 추출할 컬럼 리스트

## 처리 방법
1. CSV 파일 읽기
2. 지정된 컬럼만 필터링
3. 결과를 JSON으로 변환

## 출력
{"columns": [...], "data": [...]}

## 제약 조건
- 파일 크기 100MB 이하만 처리
- 컬럼이 없으면 에러 반환
```

### 아키텍트 에이전트 (워크플로우 설계 및 관리)
**필수 원칙**:
- SSOT, SoC, MECE (시스템 구조 관리)
- 피드백 루프 (워커 검증)
- 투명성·추적성 (작업 로그 관리)

**예시 구조**:
```markdown
# 콘텐츠 생성 아키텍트

## 목적
복잡한 콘텐츠 생성 작업을 워커들에게 분배하고 감독

## 역할
프로젝트 매니저

## 책임
1. 작업 계획 수립 (Work Breakdown)
2. 워커 에이전트 선택 및 할당
3. 산출물 평가 및 검증
4. 실패 시 재시도 또는 재할당

## 처리 방법
1. 사용자 요청 분석
2. 태스크 분해 (리서치 → 초안 → 검수)
3. 각 워커에게 작업 할당
4. 각 단계 산출물 검증
5. 최종 결과 종합

## 출력
최종 통합 보고서 + 작업 로그

## 제약 조건
- 워커 실패 시 최대 3회 재시도
- 모든 워커 산출물을 _job_log.json에 기록
```

## 5. 실전 체크리스트

에이전트 설계 시 다음을 확인하세요:

### 모든 에이전트
- [ ] 8가지 구성 요소가 모두 정의되었는가?
- [ ] 출력 형식이 명확히 정의되었는가? (JSON Schema 등)
- [ ] 제약 조건이 명시되었는가?

### 워커 에이전트
- [ ] 단일 책임 원칙을 따르는가?
- [ ] 입력과 출력이 명확한가?
- [ ] 컨텍스트 윈도우 내에 들어가는가? (인스트럭션 20-30% 이하)

### 아키텍트 에이전트
- [ ] 워커들의 역할이 MECE 원칙을 따르는가?
- [ ] 워커 산출물을 어떻게 검증할지 정의되었는가?
- [ ] 실패 처리 전략이 있는가?

### 메타 에이전트
- [ ] 시스템 전체 목표가 명확한가?
- [ ] 아키텍트 선택/생성 기준이 있는가?
- [ ] 성능 지표 모니터링 방법이 정의되었는가?
