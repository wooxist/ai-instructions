# 워커 에이전트 패턴

> 이 문서는 구체적인 작업을 실행하는 워커 에이전트의 설계 패턴과 다양한 유형별 예시를 제공합니다.

## 1. 워커 에이전트 기본

### 1.1 정의와 특징

**워커 에이전트**는:
- **단일하고 명확한 태스크**만 수행
- 다른 에이전트나 전체 워크플로우를 알 필요 없음
- 주어진 입력을 명시된 출력으로 변환하는 **순수 함수**처럼 동작

**핵심 특징**:
- 원자성 (Atomicity): 더 이상 나눌 수 없는 최소 단위
- 재사용성 (Reusability): 다양한 워크플로우에서 활용 가능
- 예측성 (Predictability): 같은 입력 → 같은 출력

### 1.2 워커 vs 아키텍트

| 항목 | 워커 | 아키텍트 |
|------|------|----------|
| 역할 | 실행자 | 관리자 |
| 범위 | 단일 태스크 | 전체 워크플로우 |
| 책임 | 산출물 생성 | 워커 조율, 검증 |
| 지식 | 자신의 작업만 | 전체 프로세스 |
| 출력 | 데이터/파일 | 통합 결과 + 로그 |

## 2. 워커 유형별 패턴

### 2.1 분류 워커 (Classifier)

**목적**: 입력을 사전 정의된 카테고리로 분류

**특징**:
- 카테고리는 MECE 원칙 따름
- Confidence score 포함 권장
- 불확실성 처리 전략 필요

**템플릿**:
```markdown
# [분류 대상] 분류 워커

## 목적
[대상]을 [카테고리1, 카테고리2, ...]로 분류

## 역할
[도메인] 분류 전문가

## 입력
- input_text: 분류할 텍스트/데이터
- (optional) context: 추가 맥락 정보

## 처리 방법
1. 입력 텍스트 분석
2. 가장 적합한 카테고리 판단
3. 신뢰도 점수 계산

## 출력
```json
{
  "item_id": "...",
  "category": "category1|category2|category3",
  "confidence": 0.95,
  "reasoning": "분류 근거"
}
```

## 제약 조건
- confidence < 0.7이면 category = "uncertain"
- 반드시 하나의 카테고리만 선택
- reasoning은 한 문장으로 간결하게

## 평가 기준
- [ ] category가 정의된 값 중 하나
- [ ] confidence는 0~1 사이
- [ ] reasoning이 비어있지 않음
```

**실전 예시 1: 고객 리뷰 분류기**
```markdown
# 고객 리뷰 분류기

## 목적
고객 리뷰를 제품/배송/CS 카테고리로 분류

## 역할
고객 경험 분석 전문가

## 입력
```json
{
  "review_id": "R12345",
  "text": "배터리는 좋은데 배송이 너무 느렸어요"
}
```

## 처리 방법
1. 리뷰 텍스트에서 핵심 키워드 파악
2. 각 카테고리와의 관련성 평가
   - 제품: 제품 기능, 품질, 디자인 관련
   - 배송: 배송 속도, 포장 상태 관련
   - CS: 고객 서비스, 응대 관련
3. 가장 관련성 높은 카테고리 선택
4. 신뢰도 계산

## 출력
```json
{
  "review_id": "R12345",
  "category": "delivery",
  "confidence": 0.85,
  "reasoning": "배송 속도에 대한 불만이 주요 내용"
}
```

## 제약 조건
- 여러 주제가 섞여있어도 가장 주된 주제 1개만 선택
- confidence < 0.7이면 "mixed" 카테고리 사용
- 제품명이나 고객명은 분류 근거에 포함하지 말 것

## 평가 기준
- [ ] category ∈ {product, delivery, cs, mixed}
- [ ] confidence ∈ [0, 1]
- [ ] reasoning은 20단어 이내
```

**실전 예시 2: 긴급도 분류기**
```markdown
# 고객 문의 긴급도 분류기

## 목적
고객 문의를 긴급도(urgent/normal/low)로 분류

## 입력
- ticket_id
- subject: 제목
- content: 본문
- submitted_at: 접수 시각

## 처리 방법
1. 긴급 키워드 탐지 ("즉시", "긴급", "서비스 중단" 등)
2. 비즈니스 영향 평가 (결제 실패 > 기능 문의)
3. 시간 민감도 판단

## 출력
```json
{
  "ticket_id": "T001",
  "priority": "urgent|normal|low",
  "sla_hours": 1|4|24,
  "confidence": 0.9
}
```

## 분류 기준
- urgent: 서비스 중단, 결제 오류, 보안 이슈
- normal: 기능 오류, 개선 요청
- low: 일반 문의, 피드백

## 제약 조건
- 불확실하면 한 단계 높은 우선순위로 분류 (안전 중시)
```

### 2.2 추출 워커 (Extractor)

**목적**: 비정형 데이터에서 구조화된 정보 추출

**특징**:
- 입력: 비정형 텍스트/문서
- 출력: 구조화된 JSON
- 필드 누락 시 null 처리 전략

**템플릿**:
```markdown
# [대상] 정보 추출 워커

## 목적
[대상]에서 [필드1, 필드2, ...]를 추출

## 역할
데이터 추출 전문가

## 입력
- source_text: 원본 텍스트
- extraction_schema: 추출할 필드 정의

## 처리 방법
1. 각 필드에 해당하는 정보 탐색
2. 정보가 없는 필드는 null 처리
3. 추출된 정보의 신뢰도 평가

## 출력
```json
{
  "extracted_data": {
    "field1": "value1",
    "field2": null,
    "field3": "value3"
  },
  "confidence_scores": {
    "field1": 0.95,
    "field3": 0.88
  }
}
```

## 제약 조건
- 추측하지 말고 명시적인 정보만 추출
- 정보가 없으면 null (빈 문자열 아님)
- confidence < 0.6이면 "uncertain" 태그
```

**실전 예시: 이력서 정보 추출기**
```markdown
# 이력서 정보 추출기

## 목적
이력서에서 핵심 정보를 구조화하여 추출

## 입력
- resume_text: 이력서 원문 (PDF 변환된 텍스트)

## 처리 방법
1. 이름: 문서 상단의 가장 큰 글씨 또는 첫 줄
2. 이메일: 이메일 패턴 검색 (regex)
3. 경력: "경력", "Experience" 섹션에서 연수 계산
4. 학력: "학력", "Education" 섹션에서 최종 학위
5. 기술 스택: "기술", "Skills" 섹션에서 항목 추출

## 출력
```json
{
  "name": "홍길동",
  "email": "hong@example.com",
  "years_of_experience": 5,
  "highest_degree": "석사",
  "skills": ["Python", "JavaScript", "SQL"],
  "confidence": {
    "name": 0.99,
    "email": 1.0,
    "years_of_experience": 0.85,
    "highest_degree": 0.90,
    "skills": 0.75
  }
}
```

## 제약 조건
- 개인정보 보호: 주민등록번호는 추출 금지
- 기술 스택은 최대 10개까지만
- 정보 없으면 null, 절대 추측하지 말 것
```

### 2.3 변환 워커 (Transformer)

**목적**: 데이터를 한 형식에서 다른 형식으로 변환

**특징**:
- 입력과 출력의 정보량은 동일
- 손실 없는 변환이 원칙
- 역변환 가능성 고려

**템플릿**:
```markdown
# [입력 형식] → [출력 형식] 변환 워커

## 목적
[입력]을 [출력] 형식으로 변환

## 입력
- source: [입력 형식] 데이터
- options: 변환 옵션

## 처리 방법
1. 입력 형식 검증
2. 필드 매핑
3. 데이터 타입 변환
4. 출력 형식 생성

## 출력
[출력 형식] 데이터

## 제약 조건
- 정보 손실 없이 변환
- 원본 데이터는 수정하지 않음
```

**실전 예시: CSV → JSON 변환기**
```markdown
# CSV → JSON 변환 워커

## 목적
CSV 파일을 JSON 배열로 변환

## 입력
- csv_file_path: CSV 파일 경로
- options:
  - header_row: true (첫 줄이 헤더인지)
  - encoding: "utf-8"

## 처리 방법
1. CSV 파일 읽기
2. 헤더 행을 키로 사용
3. 각 데이터 행을 JSON 객체로 변환
4. 배열로 묶어 출력

## 출력
```json
[
  {"name": "Alice", "age": 30, "city": "Seoul"},
  {"name": "Bob", "age": 25, "city": "Busan"}
]
```

## 제약 조건
- 빈 셀은 null 처리
- 숫자형은 문자열로 변환하지 말고 number 타입 유지
- 날짜는 ISO 8601 형식으로 정규화
```

### 2.4 생성 워커 (Generator)

**목적**: 새로운 콘텐츠/데이터 생성

**특징**:
- 창의성이 필요한 작업
- 품질 기준이 주관적일 수 있음
- 검증 워커와 쌍으로 사용 권장

**템플릿**:
```markdown
# [콘텐츠 유형] 생성 워커

## 목적
[요구사항]에 맞는 [콘텐츠]를 생성

## 역할
[직무] 전문가 (예: 시니어 카피라이터)

## 입력
- requirements: 요구사항 명세
- context: 배경 정보
- style_guide: 스타일 가이드 (선택)

## 처리 방법
1. 요구사항 분석
2. 컨텍스트 파악
3. 초안 생성
4. 스타일 가이드 적용

## 출력
[생성된 콘텐츠 + 메타데이터]

## 제약 조건
- 분량: [최소-최대]
- 톤앤매너: [설명]
- 금지 사항: [목록]

## 평가 기준
- [ ] 요구사항 충족
- [ ] 분량 준수
- [ ] 스타일 일관성
```

**실전 예시 1: 이메일 초안 생성기**
```markdown
# 고객 응대 이메일 생성기

## 목적
고객 문의에 대한 정중하고 전문적인 답변 이메일 초안 생성

## 역할
10년차 고객 서비스 전문가

## 입력
```json
{
  "customer_inquiry": "제품이 고장났는데 환불 가능한가요?",
  "context": {
    "product": "노트북 A",
    "purchase_date": "2024-09-15",
    "warranty_status": "active"
  },
  "policy": "14일 이내 전액 환불, 이후 AS"
}
```

## 처리 방법
1. 문의 내용 파악
2. 정책 확인 (warranty_status, purchase_date)
3. 적절한 해결책 결정
4. 정중한 톤으로 답변 작성

## 출력
```json
{
  "subject": "노트북 A 환불 요청 관련 안내",
  "body": "안녕하세요, 고객님...",
  "action_items": [
    "고객에게 반품 주소 안내",
    "환불 처리 (3-5 영업일 소요)"
  ]
}
```

## 제약 조건
- 톤: 정중하고 공감적
- 길이: 100-200 단어
- 반드시 포함: 인사, 상황 확인, 해결책, 후속 조치
- 금지: 확정되지 않은 약속, 다른 고객과의 비교

## 평가 기준
- [ ] 고객 문의에 직접 답변
- [ ] 회사 정책 준수
- [ ] 정중하고 공감적인 톤
- [ ] 명확한 action items
```

**실전 예시 2: 소셜 미디어 포스트 생성기**
```markdown
# 트위터 포스트 생성기

## 목적
주제에 맞는 흥미롭고 간결한 트윗 생성

## 역할
소셜 미디어 전문 카피라이터

## 입력
- topic: 포스팅 주제
- key_message: 핵심 메시지
- tone: "professional|casual|humorous"

## 처리 방법
1. 핵심 메시지를 140자 이내로 압축
2. 톤에 맞는 표현 선택
3. 이모지 1-2개 추가 (선택)
4. 해시태그 추천 (최대 3개)

## 출력
```json
{
  "tweet": "AI 인스트럭션 설계, 생각보다 어렵지 않아요! 💡 단계별로 따라하면 누구나 가능합니다. #AI활용 #생산성",
  "character_count": 68,
  "hashtags": ["AI활용", "생산성", "인스트럭션"],
  "tone_applied": "casual"
}
```

## 제약 조건
- 길이: 최대 140자 (한글 기준)
- 이모지: 0-2개
- 해시태그: 최대 3개
- 금지: 공격적 언어, 정치적 발언
```

### 2.5 검증 워커 (Validator/Reviewer)

**목적**: 생성된 콘텐츠나 데이터의 품질 검증

**특징**:
- 평가 기준이 명확해야 함
- 정량적 점수 + 정성적 피드백
- 승인/거부/수정 요청 결정

**템플릿**:
```markdown
# [대상] 검증 워커

## 목적
[대상]의 품질을 [기준]에 따라 평가

## 역할
[도메인] 품질 관리 전문가

## 입력
- artifact: 검증할 산출물
- criteria: 평가 기준 정의
- reference: 참고 자료 (선택)

## 평가 차원
1. [차원1]: [설명] (0-100점)
2. [차원2]: [설명] (0-100점)
3. [차원3]: [설명] (0-100점)

## 출력
```json
{
  "scores": {
    "dimension1": 85,
    "dimension2": 70,
    "dimension3": 90
  },
  "overall": 81.7,
  "decision": "approve|revise|reject",
  "feedback": "구체적인 개선 제안"
}
```

## 판단 기준
- overall >= 80: approve
- 60-79: revise (피드백 제공)
- < 60: reject

## 제약 조건
- 객관적 근거 기반 평가
- 피드백은 실행 가능해야 함
```

**실전 예시: 코드 리뷰 워커**
```markdown
# 파이썬 코드 리뷰 워커

## 목적
파이썬 코드의 품질을 평가하고 개선 사항 제안

## 역할
10년차 시니어 파이썬 개발자

## 입력
- code_file: 검토할 코드 파일
- context: 코드 목적 및 요구사항

## 평가 차원
1. 가독성 (Readability) 0-100
   - 변수/함수명 명확성
   - 주석 적절성
   - 코드 구조 (함수 분리)

2. 성능 (Performance) 0-100
   - 시간 복잡도
   - 공간 복잡도
   - 비효율적 패턴 (예: 중복 루프)

3. 안전성 (Safety) 0-100
   - 예외 처리
   - 입력 검증
   - 보안 취약점 (SQL injection 등)

4. 유지보수성 (Maintainability) 0-100
   - 함수 길이 적절성
   - 중복 코드 최소화
   - 테스트 가능성

## 출력
```json
{
  "scores": {
    "readability": 85,
    "performance": 70,
    "safety": 90,
    "maintainability": 75
  },
  "overall": 80,
  "decision": "approve",
  "feedback": "성능: 라인 45의 리스트 컴프리헨션을 제너레이터로 변경하면 메모리 효율 개선 가능",
  "critical_issues": [],
  "suggestions": [
    "함수 parse_data()를 2개로 분리 권장"
  ]
}
```

## 판단 기준
- overall >= 80 AND no critical_issues: approve
- overall >= 60 OR critical_issues 있음: revise
- overall < 60: reject

## 제약 조건
- 코드 스타일은 PEP 8 기준
- critical_issues: 보안 취약점, 명백한 버그만
- suggestions는 3개 이내로 우선순위 높은 것만
```

### 2.6 요약 워커 (Summarizer)

**목적**: 긴 텍스트를 핵심 정보만 추려 요약

**특징**:
- 정보 손실 최소화
- 대상 독자에 맞는 톤 조절
- 길이 제약 엄수

**템플릿**:
```markdown
# [문서 유형] 요약 워커

## 목적
[문서]를 [길이]로 요약

## 역할
전문 에디터

## 입력
- source_document: 원본 문서
- target_length: 목표 길이 (단어/문장 수)
- audience: 대상 독자

## 처리 방법
1. 핵심 주제 파악
2. 중요 정보 선별
3. 대상 독자 수준에 맞게 표현
4. 목표 길이에 맞춤

## 출력
```json
{
  "summary": "요약 본문",
  "word_count": 150,
  "key_points": ["핵심1", "핵심2", "핵심3"]
}
```

## 제약 조건
- 원문의 사실 왜곡 금지
- 개인 의견 추가 금지
- 길이 제약 엄수
```

**실전 예시: 회의록 요약 워커**
```markdown
# 회의록 요약 워커

## 목적
회의록을 핵심 결정사항과 액션 아이템 중심으로 요약

## 입력
- meeting_notes: 회의록 원문
- participants: 참석자 목록

## 처리 방법
1. 주요 결정사항 식별 (최대 3개)
2. 액션 아이템 추출 (담당자, 기한 포함)
3. 다음 회의 일정 확인
4. 표준 형식으로 정리

## 출력
```markdown
## 회의 핵심 결정사항 (3가지)
- [결정사항 1]
- [결정사항 2]
- [결정사항 3]

## Action Items
- [할 일 1] - 담당자: [이름], 기한: [YYYY-MM-DD]
- [할 일 2] - 담당자: [이름], 기한: [YYYY-MM-DD]

## 다음 회의
- 일시: [날짜]
```

## 제약 조건
- 결정사항: 정확히 3개 (적으면 "주요 결정 없음"도 포함)
- 액션 아이템: 담당자와 기한 필수
- 개인 의견이나 추측 배제
```

## 3. 복잡도별 워커 설계 가이드

### 3.1 간단한 작업 (낮은 위험, 단순 반복)

**특징**: 명확한 규칙, 주관성 최소

**필수 원칙**:
- 산출물 중심 (명확한 출력)

**예시**:
```markdown
# 이메일 주소 검증 워커

## 목적
이메일 주소 형식 유효성 검사

## 입력
- email: string

## 처리
정규식으로 이메일 형식 검증

## 출력
```json
{"email": "test@example.com", "valid": true}
```

## 제약
- RFC 5322 표준 준수
```

### 3.2 전문적 작업 (중간 복잡도, 전문 지식)

**필수 원칙**:
- 산출물 중심
- SSOT (지식 출처 한정)
- 컨텍스트 명시성
- 투명성·추적성

**예시**:
```markdown
# 법률 조항 분석 워커

## 역할
15년차 기업 법무 변호사 (보조)

## 입력
- contract_clause: 계약 조항
- analysis_scope: ["liability", "termination", "ip"]

## 지식 출처 (SSOT)
- 허용 자료: company_legal_db, case_law_2020_2024
- 외부 인터넷 검색 금지

## 출력
```json
{
  "risks": [
    {
      "clause_id": "5.2",
      "risk_level": "high|medium|low",
      "description": "...",
      "recommendation": "...",
      "cited_precedent": "case_law_2020_2024:doc_123"
    }
  ],
  "disclaimer": "이는 법률 자문이 아니며, 최종 결정은 변호사와 협의 필요"
}
```

## 제약
- 모든 주장은 cited_precedent 필수
- 추측 금지, "판단 불가" 명시
- 개인 의견 배제
```

### 3.3 복잡한 작업 (높은 위험, 법적 책임)

**필수 원칙**: 모든 원칙 적용

**예시**:
```markdown
# 재무 데이터 분석 워커

## 역할
공인회계사 (CPA)

## 목적
재무제표 이상 징후 탐지

## 입력
- financial_statements: 재무제표 데이터
- previous_year: 전년도 비교 데이터

## 지식 출처 (SSOT)
- 회계 기준: K-IFRS_2024
- 내부 정책: company_financial_policy_v3

## 처리 방법
1. 주요 재무 비율 계산
2. 전년도 대비 변화율 분석
3. 이상 패턴 탐지 (±30% 이상 변동)
4. K-IFRS 기준 준수 여부 확인

## 출력
```json
{
  "analysis_id": "FA_2024_Q3",
  "anomalies": [
    {
      "metric": "debt_ratio",
      "current": 0.75,
      "previous": 0.45,
      "change_pct": 66.7,
      "severity": "high",
      "ifrs_ref": "K-IFRS_2024:section_3.2",
      "recommendation": "부채 비율 급증, 원인 조사 필요"
    }
  ],
  "overall_risk": "medium",
  "reviewer_note": "전문 회계사의 추가 검토 권장",
  "confidence": 0.85
}
```

## 제약
- 모든 지표는 ifrs_ref 인용 필수
- confidence < 0.7이면 사람 검토 요청
- 절대 재무적 조언 제공 금지
- 개인정보(급여 등) 노출 금지

## Human-in-the-Loop
- severity = "high"인 anomalies 발견 시
- 즉시 담당 CFO에게 알림
- 사람 승인 후에만 보고서 발행

## 감사 추적
모든 분석 근거를 `audit_log.json`에 기록:
- 사용한 데이터 소스
- 적용한 계산식
- 참조한 회계 기준
```

## 4. 실전 체크리스트

새 워커 설계 시:

### 기본 구조
- [ ] 8가지 구성 요소 포함
- [ ] 단일 책임 원칙 (하나의 명확한 작업)
- [ ] 입출력 형식 명확

### 재사용성
- [ ] 다른 워크플로우에서도 사용 가능?
- [ ] 특정 컨텍스트에 과도하게 의존하지 않음?
- [ ] 이름이 범용적이고 명확?

### 품질 보장
- [ ] 구조화된 출력 (JSON Schema)
- [ ] Few-shot 예시 포함?
- [ ] 평가 기준 정의됨?
- [ ] 에러 처리 전략 있음?

### 복잡도별
**간단**: 산출물 중심만
**전문**: + SSOT, 컨텍스트 명시성
**복잡**: + 모든 원칙, Human-in-the-Loop

## 5. 워커 라이브러리 구축 전략

### 5.1 범용 워커 먼저
자주 사용되는 범용 워커부터 구축:
- 분류기 (텍스트 카테고리화)
- 추출기 (JSON 추출)
- 변환기 (CSV↔JSON)
- 요약기 (텍스트 요약)

### 5.2 도메인 특화 워커
조직 특성에 맞는 전문 워커:
- 업계 용어 분류기
- 자사 제품 리뷰 분석기
- 내부 규정 검증기

### 5.3 버전 관리
- 워커 개선 시 v1, v2로 버전 관리
- 하위 호환성 유지
- 변경 이력 문서화

### 5.4 테스트 데이터셋
각 워커마다:
- 골든 데이터셋 (정답 포함)
- 엣지 케이스 (경계값, 오류 상황)
- 성능 벤치마크 기준
