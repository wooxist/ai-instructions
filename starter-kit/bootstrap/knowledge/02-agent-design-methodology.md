# 에이전트 설계 방법론

> **메타 에이전트 지시사항:**
> 당신의 임무는 새로운 에이전트 생성이 필요할 때마다, 이 문서에 정의된 **5단계 설계 절차**를 엄격히 따르는 것이다. 이 절차의 최종 산출물은 `01-core-principles.md`의 모든 원칙을 준수하는 완벽한 **에이전트 인스트럭션 파일(.md)**이다.
>
> 1.  **이유(Why):** 왜 에이전트로 나누는가?
> 2.  **범위(Scoping):** 에이전트를 얼마나 크게 만들 것인가?
> 3.  **소통(I/O):** 에이전트는 어떻게 소통하는가?
> 4.  **협업(Workflow):** 에이전트들은 어떻게 협력하는가?
> 5.  **구현(Implementation):** 최종 인스트럭션 파일을 어떻게 작성하는가?

## 1단계: 이유 (Why) - AI 한계 극복

하나의 거대 인스트럭션 대신 여러 전문 에이전트로 나누어 설계하는 이유는 AI의 본질적 한계를 극복하고 안정성을 확보하기 위함입니다.

| 문제점 | 설명 | 해결 전략 |
| :--- | :--- | :--- |
| **컨텍스트 윈도우** | 지시가 길어지면 AI는 앞부분의 중요 규칙을 잊어버립니다. | **역할 분할**: 에이전트의 역할을 잘게 나누어 각 인스트럭션의 길이를 물리적으로 줄입니다. |
| **할루시네이션** | 사실이 아닌 정보를 그럴듯하게 지어냅니다. | **근거 기반 책임**: "제공된 문서 내에서만 답변하고, 모든 주장은 출처를 명시하라"고 제약합니다.<br>**검증 에이전트 분리**: 생성과 검증의 역할을 분리하여 품질을 보장합니다. |
| **비일관성** | 동일한 지시에도 매번 다른 결과물을 생성합니다. | **페르소나 구체화**: "당신은 20년차 변호사..." 와 같이 구체적인 역할을 부여하여 톤앤매너를 고정합니다.<br>**구조화된 출력 강제**: JSON Schema 등을 사용해 출력 형식을 엄격히 제어합니다. |
| **유지보수/확장성** | 거대 인스트럭션은 수정과 재사용이 어렵습니다. | **모듈화**: 각 에이전트를 독립적인 부품처럼 설계하여 교체 및 재사용이 용이하게 합니다. |

## 2단계: 범위 결정 (Scoping)

에이전트 설계를 시작할 때 가장 먼저 결정할 것은 '에이전트의 크기', 즉 책임의 범위입니다.

### 2.1. 물리적 제약: 컨텍스트 윈도우

**경험 법칙**:
1.  **인스트럭션 비율**: 전체 컨텍스트의 **20-30% 이하**로 유지합니다.
2.  **분리 기준**: `[인스트럭션 길이] + [평균 입력 데이터] > [컨텍스트의 70%]` 라면 에이전트 분리를 강력히 고려합니다.

### 2.2. 설계 원칙: 단일 책임 (SRP)

에이전트 분리 여부는 다음 3가지 관점으로 판단합니다.

| 관점 | 질문 | 분리 예시 | 통합 예시 |
| :--- | :--- | :--- | :--- |
| **전문성** | 서로 다른 전문 지식을 요구하는가? | `UI 디자인 에이전트` vs `DB 스키마 에이전트` | `버튼 생성` + `텍스트 필드 생성` → `UI 위젯 에이전트` |
| **재사용성** | 다른 워크플로우에서도 재사용될 수 있는가? | `코드 리뷰 에이전트` (모든 코드 생성 작업에 재사용) | `주간 보고서 서론 작성` (특정 워크플로우에만 사용) |
| **응집도** | 하나의 목적을 위해 긴밀하게 묶여 있는가? | `이메일 생성` vs `SQL 쿼리 실행` (관련 없는 작업) | `이메일 형식 검증` + `내용 생성` → `이메일 생성 에이전트` |

## 3단계: 소통 방식 설계 (Input/Output)

에이전트의 소통 방식을 정의합니다. **원하는 출력을 먼저 정의**한 후, 필요한 입력을 역으로 설계하는 것이 가장 효과적입니다.

| 기법 | 설명 | 예시 |
| :--- | :--- | :--- |
| **JSON Schema** | 출력 형식을 스키마로 강제하여 일관성과 기계 가독성을 보장합니다. | `output_schema`에 JSON Schema를 명시하여 `summary`, `categories`, `priority` 필드를 필수로 지정합니다. |
| **Few-Shot 예시** | 1~2개의 입출력 예시를 제공하여 AI가 패턴을 학습하게 합니다. | `입력: "앱이 꺼져요" → 출력: {"category": "bug"}` 예시를 제공합니다. |
| **평가 기준 명시** | 결과물의 성공 기준을 체크리스트로 제공하여 AI가 스스로 검증하게 합니다. | `## 평가 기준: [ ] 300단어 미만, [ ] 핵심 내용 포함` 등을 명시합니다. |
| **의도 확인 루프** | 모호한 요청에는 AI가 질문으로 명세를 구체화하도록 설계합니다. | `"번역해줘"` → `(AI 질문) "어떤 스타일(격식/구어체)로 번역할까요?"` |

## 4단계: 협업 방식 설계 (Workflow)

개별 에이전트들을 연결하여 복잡한 작업을 수행하는 협업 패턴을 정의합니다.

| 패턴 | 설명 | 흐름 예시 |
| :--- | :--- | :--- |
| **파이프라인** | 한 에이전트의 출력이 다음 에이전트의 입력으로 순차 전달됩니다. | `[데이터 수집] → [데이터 정제] → [보고서 생성]` |
| **생성-검증** | 생성과 검증을 반복하며 결과물의 품질을 보장합니다. | `[생성 에이전트] ↔ [검증 에이전트]` 루프 |
| **라우팅** | 특정 조건에 따라 작업의 흐름을 동적으로 결정합니다. | `[분류] → (if urgent) [긴급 처리] or (if normal) [일반 처리]` |

## 5단계: 구현 (템플릿 기반)

> **메타 에이전트 지시사항:**
> 이전 4단계의 모든 분석과 설계를 종합하여, 아래 템플릿을 사용해 최종 인스트럭션 파일을 완성하라. 이 단계는 추상적인 설계를 구체적인 실행 코드로 변환하는 최종 과정이다.

### 5.1. 워커 에이전트 템플릿

> **지침:** 새로운 워커 에이전트를 생성할 때, 반드시 이 템플릿을 사용하시오. 각 섹션은 아키텍트의 요구사항이나 시스템 목표에 따라 구체적이고 명확하게 채워져야 합니다. 특히 `평가 기준`은 반드시 측정 가능해야 합니다.

```markdown
# [워커 에이전트 이름] (예: CSV 데이터 추출기)

## 1. 목적: [한 문장 목표]
## 2. 역할: [전문가 페르소나]
## 3. 입력:
  - param1: [설명, 타입, 예시]
## 4. 처리 방법:
  1. [단계 1]
  2. [단계 2]
## 5. 출력:
  ### 형식: [JSON Schema 또는 구조 설명]
  ### 예시:
  ```json
  { "field1": "value1" }
  ```
## 6. 제약 조건:
  - [필수 규칙 1]
  - [금지 사항 1]
## 7. 평가 기준:
  - [ ] [측정 가능한 기준 1]
## 8. 기초 지식: [항상 참고할 원칙]
```

### 5.2. 아키텍트 에이전트 템플릿

> **지침:** 새로운 아키텍트 에이전트를 생성할 때, 반드시 이 템플릿을 사용하시오. 아키텍트의 핵심 책임은 `워크플로우 정의`를 통해 여러 워커들을 어떻게 조율할지 명시하는 것입니다. 이 워크플로우는 아키텍트가 실제 작업을 수행할 때의 청사진이 됩니다.

```markdown
# [아키텍트 이름] (예: 콘텐츠 생성 아키텍트)

## 1. 목적: [복잡한 워크플로우의 최종 목표]
## 2. 역할: 프로젝트 매니저 / 워크플로우 설계자
## 3. 책임:
  1. Work Breakdown: [작업 분해 방법]
  2. 워커 할당: [적합한 워커 선택 기준]
  3. 산출물 검증: [검증 방법]
  4. 예외 처리: [실패 시 대응]
## 4. 관리 대상 워커:
  - worker-1: [역할]
  - worker-2: [역할]
## 5. 워크플로우 정의 (`workflow.yaml`):
  name: "콘텐츠 생성 및 검증 워크플로우"
  steps:
    - name: draft_content
      agent: worker-1
      ...
    - name: verify_content
      agent: worker-2
      ...
## 6. 실패 처리:
  - 재시도: 최대 [N]회
  - 에스컬레이션: [사람 개입 조건]
## 7. 로깅:
  - 모든 워커 작업을 `_job_log.json`에 기록
```
