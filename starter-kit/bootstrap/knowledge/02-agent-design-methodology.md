# 에이전트 설계 방법론

> 이 문서는 메타 에이전트가 새로운 아키텍트 및 워커 에이전트를 설계할 때 따라야 할 구체적인 방법론을 제공합니다.

## 1. 에이전트 범위 결정 (Scoping)

### 1.1. 물리적 제약: 컨텍스트 윈도우

**토큰 예산 개념**: `총 컨텍스트 윈도우 = 인스트럭션 + 입력 데이터 + 출력 데이터`

**경험 법칙**:
1.  **인스트럭션 비율**: 전체 컨텍스트의 **20-30% 이하**로 유지합니다.
2.  **분리 기준**: `[인스트럭션 길이] + [평균 입력 데이터] > [컨텍스트의 70%]` 라면 에이전트 분리를 강력히 고려합니다.
3.  **최소 기능 인스트럭션**: 작동하는 가장 짧은 버전으로 시작하고, 필요시 점진적으로 확장합니다.

### 1.2. 설계 원칙: 단일 책임 (SRP)

에이전트 분리 여부는 다음 3가지 관점으로 판단합니다.

| 관점 | 질문 | 분리 예시 | 통합 예시 |
| :--- | :--- | :--- | :--- |
| **전문성** | 서로 다른 전문 지식을 요구하는가? | `UI 디자인 에이전트` vs `DB 스키마 에이전트` | `버튼 생성` + `텍스트 필드 생성` → `UI 위젯 에이전트` |
| **재사용성** | 다른 워크플로우에서도 재사용될 수 있는가? | `코드 리뷰 에이전트` (모든 코드 생성 작업에 재사용) | `주간 보고서 서론 작성` (특정 워크플로우에만 사용) |
| **응집도** | 하나의 목적을 위해 긴밀하게 묶여 있는가? | `이메일 생성` vs `SQL 쿼리 실행` (관련 없는 작업) | `이메일 형식 검증` + `내용 생성` → `이메일 생성 에이전트` |

## 2. 입출력 설계 (Input/Output)

### 2.1. 출력 우선 설계 (Output-Driven)

**원칙**: 원하는 출력을 먼저 명확히 정의한 후, 그에 필요한 입력을 역으로 설계합니다.

**예시: 번역 에이전트**
1.  **[출력 정의]** 단순 텍스트가 아닌, 메타데이터를 포함한 JSON 구조를 먼저 정의합니다.
    ```json
    {
      "original_text": "...",
      "translated_text": "...",
      "style": "formal|casual|poetic",
      "explanation": "번역 스타일 선택 이유"
    }
    ```
2.  **[입력 역산]** 위 출력을 만들려면 `source_text`, `target_language`, `style_preference`, `context`가 필요함을 도출합니다.

### 2.2. 구조화된 출력 기법

| 기법 | 설명 | 예시 |
| :--- | :--- | :--- |
| **JSON Schema** | 출력 형식을 스키마로 강제하여 일관성과 기계 가독성을 보장합니다. | `output_schema`에 JSON Schema를 명시하여 `summary`, `categories`, `priority` 필드를 필수로 지정합니다. |
| **Few-Shot 예시** | 1~2개의 입출력 예시를 제공하여 AI가 패턴을 학습하게 합니다. | `입력: "앱이 꺼져요" → 출력: {"category": "bug"}` 예시를 제공합니다. |
| **평가 기준 명시** | 결과물의 성공 기준을 체크리스트로 제공하여 AI가 스스로 검증하게 합니다. | `## 평가 기준: [ ] 300단어 미만, [ ] 핵심 내용 포함` 등을 명시합니다. |

### 2.3. 동적 명세 기법: 의도 확인 루프

모호한 요청을 받았을 때, AI가 작업을 즉시 수행하는 대신 명세를 구체화하기 위해 사용자에게 질문하도록 설계합니다.
**예시**: `"번역해줘"` → `(AI 질문) "어떤 스타일(격식/구어체)로 번역할까요?"`

## 3. 워크플로우 설계 (Workflow)

개별 에이전트들을 연결하여 복잡한 작업을 수행하는 협업 패턴을 정의합니다.

### 3.1. 파이프라인 (Pipeline) 패턴

한 에이전트의 출력이 다음 에이전트의 입력으로 순차적으로 전달되는 가장 기본적인 워크플로우입니다.
**흐름**: `[데이터 수집] → [데이터 정제] → [정보 추출] → [보고서 생성]`

### 3.2. 생성-검증 (Generate-and-Verify) 패턴

한 에이전트가 결과물을 만들면(`생성`), 다른 에이전트가 그 결과물을 검증하고 피드백을 주는(`검증`) 품질 보증 패턴입니다.
**흐름**: `[생성 에이전트] ↔ [검증 에이전트]` 루프를 통해 결과물 수정 및 개선

### 3.3. 라우팅 (Routing) 패턴

특정 조건에 따라 작업의 흐름을 동적으로 결정하는 패턴입니다.

| 라우팅 유형 | 설명 | 예시 |
| :--- | :--- | :--- |
| **분류 기반** | 입력 내용에 따라 처리할 에이전트를 결정합니다. | 고객 문의 내용을 분석하여 `결제팀`, `기술지원팀`, `일반문의팀`으로 작업을 분배합니다. |
| **조건부** | 이전 단계의 결과에 따라 다음 단계를 결정합니다. | `검증 에이전트`의 결과가 '승인'이면 `최종 발행`으로, '수정 필요'이면 `초안 작성` 단계로 되돌려 보냅니다. |

## 4. AI 한계 극복 전략

| 문제점 | 해결 전략 | 적용 방법 |
| :--- | :--- | :--- |
| **할루시네이션** | **근거 기반 책임** | `## 제약: 제공된 데이터 외 정보 사용 금지. 모든 주장은 출처 명시.` |
| | **지식 출처 한정** | `knowledge_sources`에 허용된 문서 ID나 DB만 명시합니다. |
| | **검증 에이전트 분리** | 워크플로우에 `fact-checker` 에이전트를 별도 단계로 추가합니다. |
| **비일관성** | **페르소나 구체화** | `## 역할: 20년차 기업 법무팀 변호사. 고객에게는 쉬운 언어로 설명.` |
| | **구조화된 출력 강제** | `output_schema`를 사용하여 출력 형식을 엄격히 제어합니다. |

## 5. 에이전트 설계 템플릿

### 5.1. 워커 에이전트 템플릿

```markdown
# [워커 에이전트 이름] (예: CSV 데이터 추출기)

## 1. 목적: [한 문장 목표]
## 2. 역할: [전문가 페르소나]
## 3. 입력:
  - param1: [설명, 타입, 예시]
## 4. 처리 방법:
  1. [단계 1]
  2. [단계 2]
## 5. 출력:
  ### 형식: [JSON Schema 또는 구조 설명]
  ### 예시:
  ```json
  { "field1": "value1" }
  ```
## 6. 제약 조건:
  - [필수 규칙 1]
  - [금지 사항 1]
## 7. 평가 기준:
  - [ ] [기준 1]
  - [ ] [기준 2]
## 8. 기초 지식: [항상 참고할 원칙]
```

### 5.2. 아키텍트 에이전트 템플릿

```markdown
# [아키텍트 이름] (예: 콘텐츠 생성 아키텍트)

## 1. 목적: [복잡한 워크플로우의 최종 목표]
## 2. 역할: 프로젝트 매니저 / 워크플로우 설계자
## 3. 책임:
  1. Work Breakdown: [작업 분해 방법]
  2. 워커 할당: [적합한 워커 선택 기준]
  3. 산출물 검증: [검증 방법]
  4. 예외 처리: [실패 시 대응]
## 4. 관리 대상 워커:
  - content-writer: [역할]
  - fact-checker: [역할]
  - publisher: [역할]
## 5. 워크플로우 정의 (`workflow.yaml`):
  name: "콘텐츠 생성 및 검증 워크플로우"
  steps:
    - name: draft_content
      agent: content-writer
      inputs: {topic: "..."}
      outputs: {file: "draft.md"}

    - name: verify_content
      agent: fact-checker
      inputs: {file: "draft.md"}
      outputs: {result: "verification.json"}

    - name: route_based_on_verification
      agent: routing-agent # 조건부 라우팅
      inputs: {result: "verification.json"}
      # 이 라우팅 에이전트의 출력에 따라 다음 단계가 결정됨
      # 예: 출력이 "approved"이면 publish 단계로, "revision_needed"이면 draft_content 단계로 (재시도)

    - name: publish_content
      agent: publisher
      inputs: {file: "draft.md"}
      condition: "route_based_on_verification.result == 'approved'" # 실행 조건

## 6. 실패 처리:
  - 재시도: 최대 [N]회
  - 에스컬레이션: [사람 개입 조건]
## 7. 로깅:
  - 모든 워커 작업을 `_job_log.json`에 기록
```