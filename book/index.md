# 📚 AI 인스트럭션 설계 가이드북

> **참고**: 이 가이드북은 인간과 AI의 협업으로 작성되었습니다. 가이드북의 내용을 실천하는 과정에서 AI를 활용하여 만들었습니다.

## [서문: AI에게 '제대로' 일 시키는 법](00-preface.md)

# Part 1: 프롬프트와 인스트럭션의 기초
* [1장. 프롬프트와 인스트럭션 이해하기](01-introduction.md)
  * [1.1 프롬프트란?](01-introduction.md#11-프롬프트란)
  * [1.2 프롬프트를 잘 사용하려면](01-introduction.md#12-프롬프트를-잘-사용하려면)
  * [1.3 프롬프트의 한계 및 인스트럭션의 필요성](01-introduction.md#13-프롬프트의-한계-및-인스트럭션의-필요성)
* [2장. 질문 설계하기](02-questions.md)
  * [2.1 폐쇄형 질문 (Closed-ended)](02-questions.md#21-폐쇄형-질문-closed-ended)
  * [2.2 개방형 질문 (Open-ended)](02-questions.md#22-개방형-질문-open-ended)
  * [2.3 탐색형 질문 (Exploratory)](02-questions.md#23-탐색형-질문-exploratory)
  * [2.4 비교형 질문 (Comparative)](02-questions.md#24-비교형-질문-comparative)
  * [2.5 맥락 의존형 질문 (Context-dependent)](02-questions.md#25-맥락-의존형-질문-context-dependent)
  * [2.6 메타 질문 (Meta-questions)](02-questions.md#26-메타-질문-meta-questions)
* [3장. 좋은 인스트럭션](03-good-instructions.md)
  * [3.1 인스트럭션: 일회성 프롬프트를 넘어서](03-good-instructions.md#31-인스트럭션-일회성-프롬프트를-넘어서)
  * [3.2 명확성 (Clear)](03-good-instructions.md#32-명확성-clear)
  * [3.3 구체성 (Specific)](03-good-instructions.md#33-구체성-specific)
  * [3.4 단계성 (Step-wise)](03-good-instructions.md#34-단계성-step-wise)
  * [3.5 제약 조건(Constraints)과 한계 설정](03-good-instructions.md#35-제약-조건constraints과-한계-설정)
  * [3.6 실패하는 지시의 특징 (안티패턴)](03-good-instructions.md#36-실패하는-지시의-특징-안티패턴)
  * [3.7 표준 인스트럭션 템플릿: 8가지 핵심 구성 요소](03-good-instructions.md#37-표준-인스트럭션-템플릿-8가지-핵심-구성-요소)

# Part 2: 인스트럭션 시스템 설계와 평가
* [4장. 인스트럭션 설계의 메타 원칙](04-meta-principles.md)
  * [4.1 구조적 원칙: 설계의 뼈대 세우기](04-meta-principles.md#41-구조적-원칙-설계의-뼈대-세우기)
  * [4.2 실행 원칙: AI와 함께 일하는 방식 정의하기](04-meta-principles.md#42-실행-원칙-ai와-함께-일하는-방식-정의하기)
  * [4.3 검증 및 책임 원칙: 신뢰와 안전성 확보하기](04-meta-principles.md#43-검증-및-책임-원칙-신뢰와-안전성-확보하기)
  * [4.4 메타 원칙 요약표](04-meta-principles.md#44-메타-원칙-요약표)
  * [4.5 상황별 원칙 적용 가이드](04-meta-principles.md#45-상황별-원칙-적용-가이드)
* [5장. 역할(Agent)과 제약(Constraint) 설계](05-agent-constraints.md)
  * [5.1 왜 '에이전트'를 설계해야 하는가?](05-agent-constraints.md#51-왜-에이전트를-설계해야-하는가)
  * [5.2 해결 원칙과 방법론: 단일 책임을 갖는 '에이전트'로 분할하라](05-agent-constraints.md#52-해결-원칙과-방법론-단일-책임을-갖는-에이전트로-분할하라)
  * [5.3 에이전트 범위 설계를 위한 실용 가이드](05-agent-constraints.md#53-에이전트-범위-설계를-위한-실용-가이드)
* [6장. 입력과 출력 설계](06-io-design.md)
  * [6.1 왜 입력과 출력 설계가 중요한가?](06-io-design.md#61-왜-입력과-출력-설계가-중요한가)
  * [6.2 무엇을 설계해야 하는가?: 입력과 출력의 명세화](06-io-design.md#62-무엇을-설계해야-하는가-입력과-출력의-명세화)
  * [6.3 어떻게 설계하는가?: 결과물 중심 접근법과 구체적 기법](06-io-design.md#63-어떻게-설계하는가-결과물-중심-접근법과-구체적-기법)
* [7장. 처리 방법과 워크플로우 설계](07-workflow-design.md)
  * [7.1 왜 워크플로우 설계가 필요한가?](07-workflow-design.md#71-왜-워크플로우-설계가-필요한가)
  * [7.2 무엇을 설계해야 하는가?: 워크플로우의 구성 요소](07-workflow-design.md#72-무엇을-설계해야-하는가-워크플로우의-구성-요소)
  * [7.3 어떻게 설계하는가?: 견고한 워크플로우 구축 패턴](07-workflow-design.md#73-어떻게-설계하는가-견고한-워크플로우-구축-패턴)
  * [7.4 실제 워크플로우 설계 예제](07-workflow-design.md#74-실제-워크플로우-설계-예제)
  * [7.5 고급 워크플로우 패턴과 아키텍처](07-workflow-design.md#75-고급-워크플로우-패턴과-아키텍처)
* [8장. 성능 최적화: 품질, 비용, 속도의 균형 맞추기](08-performance.md)
  * [8.1 왜 성능 최적화가 필요한가?](08-performance.md#81-왜-성능-최적화가-필요한가)
  * [8.2 무엇이 성능에 영향을 미치는가?: 사용자가 제어할 수 있는 요인](08-performance.md#82-무엇이-성능에-영향을-미치는가-사용자가-제어할-수-있는-요인)
  * [8.3 어떻게 최적화하는가?: 사용자를 위한 실용적인 트레이드오프 전략](08-performance.md#83-어떻게-최적화하는가-사용자를-위한-실용적인-트레이드오프-전략)
* [9장. 인스트럭션의 평가와 검증](09-productivity.md)
  * [9.1 왜 '감'이 아닌 '기준'이 필요할까?](09-productivity.md#91-왜-감이-아닌-기준이-필요할까)
  * [9.2 무엇을 보고 개선할까?: 나만의 평가 지표 찾기](09-productivity.md#92-무엇을-보고-개선할까-나만의-평가-지표-찾기)
  * [9.3 어떻게 개선할까?: 나만의 작은 실험실](09-productivity.md#93-어떻게-개선할까-나만의-작은-실험실)
  * [9.4 정답이 있는 업무 vs. 정답이 없는 업무](09-productivity.md#94-정답이-있는-업무-vs-정답이-없는-업무)

# Part 3: 인스트럭션 시스템의 확장과 운영
* [10장 1부: 단일 에이전트 패턴](10-1-single-agent-patterns.md)
  * [10.1 [사례 1] 단일 에이전트, 간단/일상](10-1-single-agent-patterns.md#101-사례-1-단일-에이전트-간단일상)
  * [10.2 [사례 2] 단일 에이전트, 표준/전문](10-1-single-agent-patterns.md#102-사례-2-단일-에이전트-표준전문)
  * [10.3 [사례 3] 단일 에이전트, 복잡/중요](10-1-single-agent-patterns.md#103-사례-3-단일-에이전트-복잡중요)
* [10장 2부: 다중 에이전트 워크플로우](10-2-multi-agent-workflows.md)
  * [10.4 [사례 4] 다중 에이전트, 간단/일상](10-2-multi-agent-workflows.md#104-사례-4-다중-에이전트-간단일상)
  * [10.5 [사례 5] 다중 에이전트, 표준/전문](10-2-multi-agent-workflows.md#105-사례-5-다중-에이전트-표준전문)
  * [10.6 [사례 6] 다중 에이전트, 복잡/중요](10-2-multi-agent-workflows.md#106-사례-6-다중-에이전트-복잡중요)
* [10장 3부: 조직 표준 시스템](10-3-organizational-standards.md)
  * [10.7 [사례 7] 조직 표준, 간단/일상](10-3-organizational-standards.md#107-사례-7-조직-표준-간단일상)
  * [10.8 [사례 8] 조직 표준, 표준/전문](10-3-organizational-standards.md#108-사례-8-조직-표준-표준전문)
  * [10.9 [사례 9] 조직 표준, 복잡/중요](10-3-organizational-standards.md#109-사례-9-조직-표준-복잡중요)
* [10장 4부: 고급 아키텍처](10-4-advanced-architectures.md)
  * [10.10 계층적 에이전트 협력 시스템](10-4-advanced-architectures.md#1010-계층적-에이전트-협력-시스템)
  * [10.11 수평적 에이전트 협력 시스템](10-4-advanced-architectures.md#1011-수평적-에이전트-협력-시스템)
  * [10.12 시스템을 '생성'하는 메타 에이전트 (아키텍트)](10-4-advanced-architectures.md#1012-시스템을-생성하는-메타-에이전트-아키텍트)
  * [10.13 시스템을 '개선'하는 메타 에이전트 (최적화)](10-4-advanced-architectures.md#1013-시스템을-개선하는-메타-에이전트-최적화)
  * [10.14 '평가 에이전트' 직접 만들어보기](10-4-advanced-architectures.md#1014-평가-에이전트-직접-만들어보기)
* [11장. 도구(Tools)와 플러그인 활용](11-tools.md)
  * [11.1 왜 도구가 필요한가?: 뇌에 손과 발을 달아주기](11-tools.md#111-왜-도구가-필요한가-뇌에-손과-발을-달아주기)
  * [11.2 도구의 종류와 역할](11-tools.md#112-도구의-종류와-역할)
  * [11.3 에이전트에게 도구를 부여하는 방법](11-tools.md#113-에이전트에게-도구를-부여하는-방법)
  * [11.4 인스트럭션 관리 도구](11-tools.md#114-인스트럭션-관리-도구)
  * [11.5 도구 사용의 위험성과 안전장치](11-tools.md#115-도구-사용의-위험성과-안전장치)
  * [11.6 MCP: 상호운용성을 위한 표준 프로토콜](11-tools.md#116-mcp-상호운용성을-위한-표준-프로토콜)
* [12장. 워크플로우 자동화와 코드형 인프라](12-automation-iac.md) (v1-draft)
* [13장. 살아있는 시스템: 인스트럭션의 진화와 관리](13-evolution.md)
  * [13.1 조직의 성장에 따른 진화](13-evolution.md#131-조직의-성장에-따른-진화)
  * [13.2 기술의 발전에 따른 진화](13-evolution.md#132-기술의-발전에-따른-진화)
  * [13.3 에이전트의 협력과 진화: 상호운용성의 미래](13-evolution.md#133-에이전트의-협력과-진화-상호운용성의-미래)
  * [13.4 인스트럭션의 '부패'와 유지보수 (Instruction Decay)](13-evolution.md#134-인스트럭션의-부패와-유지보수-instruction-decay)
  * [13.5 최종 요약: 좋은 인스트럭션의 가치는 변하지 않는다](13-evolution.md#135-최종-요약-좋은-인스트럭션의-가치는-변하지-않는다)

## [결론: AI 시대, 지시하는 자가 미래를 지배한다](13-evolution.md#135-최종-요약-좋은-인스트럭션의-가치는-변하지-않는다)