# 7장. 워크플로우 설계: 에이전트 시스템의 협력과 자동화

**Part 2: 복잡한 인스트럭션 설계**

**목적:** 개별 에이전트들을 유기적으로 연결하여, 복잡한 실제 업무를 안정적으로 자동화하는 워크플로우를 설계하는 방법을 배웁니다.

### 이 장에서 배우는 것
- 개별 에이전트를 넘어 워크플로우 설계가 필요한 이유.
- 워크플로우를 구성하는 핵심 요소(에이전트, 태스크, 핸드오프 등)에 대한 이해.
- 파이프라인, 생성-검증 등 일반적인 워크플로우 설계 패턴.
- 실패에 대비하고 시스템의 안정성을 높이는 핸드오프 및 복원력 설계 방법.
- 에이전트 계층 구조, 동적 피드백 루프 등 고급 워크플로우 아키텍처.

## 7.1 왜 워크플로우 설계가 필요한가?

5장과 6장을 통해 우리는 명확한 역할과 입/출력 명세를 가진 개별 전문 에이전트를 만드는 법을 배웠습니다. 하지만 현실의 복잡한 문제는 단 한 명의 전문가가 해결할 수 없듯, 단일 에이전트만으로는 한계가 있습니다. 여러 에이전트가 '협력'하여 더 큰 가치를 만들게 하려면, 이들의 협력 방식을 정의하는 '워크플로우' 설계가 필수적입니다.

### 7.1.1 복잡성 관리

'신규 기능 출시'와 같은 실제 업무는 코드 작성, 테스트, 문서 업데이트, 고객 공지 등 여러 단계와 다양한 전문성이 필요합니다. 이를 하나의 거대 에이전트에게 맡기는 것은 비효율적이고 실패 확률이 높습니다. 워크플로우 설계는 이 복잡한 과업을 각 에이전트가 맡을 수 있는 작은 태스크로 나누고, 전체 프로세스를 조율하여 복잡성을 관리 가능한 수준으로 유지합니다.

### 7.1.2 불안정한 핸드오프(Handoff)

에이전트 간의 작업 전달은 마치 공장의 컨베이어 벨트와 같습니다. 한 에이전트의 결과물이 다음 에이전트가 기대하는 입력 형식과 다르면(불안정한 핸드오프[^1]), "Garbage In, Garbage Out" 문제가 에이전트 사이에서 발생하여 전체 라인이 멈춰버립니다. 워크플로우는 이 핸드오프 과정을 명확한 '계약'으로 정의하여, 시스템이 안정적으로 작동하도록 보장합니다.

### 7.1.3 연쇄 실패(Cascading Failures)

여러 에이전트가 사슬처럼 연결된 작업에서, 중간의 한 에이전트가 네트워크 오류나 예기치 않은 입력 등으로 실패하면 전체 프로세스가 중단될 수 있습니다. 실패에 대한 대비책이 없다면 시스템은 매우 취약해집니다. 워크플로우 설계는 이러한 실패 상황을 미리 예측하고, 재시도나 대체 경로 같은 '플랜 B'를 마련하여 시스템의 안정성과 복원력을 높입니다.

## 7.2 무엇을 설계해야 하는가?: 워크플로우의 구성 요소

'워크플로우'는 공동의 목표를 달성하기 위해 여러 에이전트의 태스크를 조율하는 자동화된 프로세스입니다. 잘 설계된 워크플로우는 다음과 같은 핵심 구성 요소들을 명확히 정의해야 합니다.

- **에이전트 (Agents):** 워크플로우의 '일꾼'입니다. 5장에서 설계한 것처럼, 각자 명확한 역할, 책임, 제약을 가집니다. (예: 코드 생성 에이전트, 데이터 분석 에이전트)
- **태스크 (Tasks):** 에이전트가 수행하는 개별 작업 단위입니다. 4장의 **원자성(Atomicity)** 원칙에 따라, 태스크는 '성공' 또는 '실패'로 명확히 끝나는 최소 단위로 설계하는 것이 이상적입니다.
- **핸드오프 (Handoffs):** 한 태스크(에이전트)의 결과물을 다음 태스크(에이전트)에게 전달하는 방식과 데이터에 대한 약속(프로토콜)입니다. 6장에서 설계한 입/출력 명세가 에이전트 간의 'API 계약' 역할을 합니다.
- **트리거 (Triggers):** 워크플로우를 시작시키는 이벤트입니다. 특정 시간(예: 매일 오전 9시), 특정 파일 업로드, 외부 시스템의 API 호출 등 다양합니다.
- **실패 처리 규칙 (Failure Handling Rules):** 태스크 실패 시 대처 방법을 정의한 '컨틴전시 플랜'입니다. (예: 3회까지 재시도, 실패 시 담당자에게 알림)

## 7.3 어떻게 설계하는가?: 견고한 워크플로우 구축 패턴

견고하고 효율적인 워크플로우를 구축하기 위해, 우리는 4장에서 배운 메타 원칙들을 바탕으로 몇 가지 검증된 설계 패턴과 기법을 적용할 수 있습니다. 여기서 소개하는 패턴 중 다수는 Gregor Hohpe와 Bobby Woolf가 정립한 고전적인 '엔터프라이즈 통합 패턴'[^2]에 기반을 두고 있습니다.

### 7.3.1 기본 워크플로우 패턴

- **파이프라인 패턴 (Pipeline Pattern)[^3]:** 가장 기본적인 순차 처리 구조(A → B → C)입니다. '오디오 파일 텍스트 변환 → 변환된 텍스트 요약 → 요약문 번역'과 같이, 이전 단계의 출력이 다음 단계의 입력으로 직접 이어지는 간단한 프로세스에 적합합니다.
- **생성-검증 패턴 (Generate-and-Validate Pattern):** 5장에서 할루시네이션 문제의 해결책으로 제시된 패턴입니다. 하나의 '생성 에이전트'가 초안을 만들면, 다른 '검증 에이전트'가 사실 여부, 품질, 요구사항 준수 여부를 검토하고 수정합니다. 결과물의 신뢰도를 높이는 데 매우 효과적입니다.
- **분기 패턴 (Routing Pattern):** 입력의 내용이나 조건에 따라 다음에 실행될 에이전트를 동적으로 결정하는 구조입니다. 예를 들어, '라우터 에이전트'가 고객 문의를 분석하여 '기술 지원 문의'는 개발팀 에이전트에게, '결제 문의'는 재무팀 에이전트에게 작업을 분배하는 방식입니다.

### 7.3.2 견고한 핸드오프 설계

에이전트 간의 핸드오프는 워크플로우의 가장 취약한 지점 중 하나입니다. 6장에서 배운 구조화된 입/출력 설계를 '계약'으로 활용하여 핸드오프의 안정성을 보장해야 합니다.

- **표준화된 데이터 구조:** 모든 에이전트는 JSON Schema 등으로 명확히 정의된 데이터 구조로만 소통해야 합니다. 에이전트 A의 출력 스키마는 에이전트 B의 입력 스키마와 완벽히 호환되어야 합니다.
- **상태 정보 포함:** 데이터뿐만 아니라, 이전 태스크의 성공/실패 여부, 오류가 발생했다면 오류 코드와 메시지 등 '메타데이터'를 함께 전달해야 합니다. 이를 통해 다음 에이전트는 이전 상황을 명확히 인지하고 적절한 행동을 취할 수 있습니다.

### 7.3.3 실패 및 복원력 설계

워크플로우는 반드시 실패할 수 있다는 전제하에, 4장의 **실패 안전(Fail-safe)** 원칙을 적용하여 복원력을 설계해야 합니다.

- **재시도 (Retry):** 네트워크 타임아웃이나 일시적인 API 오류와 같이, 잠시 후 다시 시도하면 성공할 가능성이 있는 오류에 대해서는 엑스포넨셜 백오프(Exponential Backoff)[^4]와 함께 2~3회 자동 재시도를 구현합니다.
- **대체 경로 (Fallback):** 핵심 에이전트가 실패했을 때, 더 단순하지만 최소한의 기능은 수행하는 '대체 에이전트'를 실행하거나, 즉시 담당자에게 알림을 보내 수동 개입을 요청하는 경로를 마련합니다.
- **모니터링 및 로깅:** 4장의 **투명성 및 추적 가능성(Transparency & Traceability)** 원칙에 따라, 모든 태스크의 시작과 끝, 입/출력 데이터, 성공/실패 상태를 로그로 기록해야 합니다. 이는 문제 발생 시 원인을 신속하게 진단하고 워크플로우를 개선하는 데 필수적입니다.

## 7.4 고급 워크플로우 패턴과 아키텍처

지금까지는 비교적 단순한 워크플로우 패턴을 살펴보았습니다. 이제 더 복잡하고 동적인 문제를 해결하기 위한 고급 아키텍처를 알아봅니다.

### 7.4.1 에이전트 계층 구조 (Agent Hierarchies)

실제 회사 조직처럼, 에이전트에게도 명확한 위계질서를 부여하여 복잡한 문제를 효율적으로 해결할 수 있습니다. 대표적인 예로 **'보스-매니저-워커'** 모델이 있습니다.

- **보스 에이전트:** 최종 목표를 이해하고, 이를 여러 매니저에게 위임합니다. (예: "우리 앱의 사용자 이탈률을 분석하고 개선안을 도출하라.")
- **매니저 에이전트:** 위임받은 중간 목표를 달성하기 위해, 여러 워커 에이전트들을 조율하고 작업 순서를 결정합니다. (예: `데이터 분석 매니저`, `리포트 생성 매니저`)
- **워커 에이전트:** 구체적인 단일 태스크를 수행합니다. (예: `DB 조회 워커`, `그래프 생성 워커`, `텍스트 요약 워커`)

### 7.4.2 동적 피드백 루프 (Dynamic Feedback Loops)

단순한 '생성-검증'을 넘어, 에이전트들이 서로의 작업을 동적으로 수정하고 개선하는 루프를 설계할 수 있습니다.

- **계층적 피드백:** 워커의 결과물이 만족스럽지 않으면, 매니저가 워커에게 수정을 지시하고, 기준을 통과할 때까지 이 과정이 반복됩니다.
- **동료 검토 (Peer Review):** 두 개의 동일한 역할을 가진 에이전트가 서로의 결과물을 교차 검토하고, 합의된 결과물을 도출하도록 하여 신뢰도를 높일 수 있습니다.

### 7.4.3 메타 에이전트 (Meta Agents)

메타 에이전트는 이 책과 프로젝트가 지향하는 궁극적인 목표입니다.

일반 에이전트가 '주어진 문제'를 푼다면, 메타 에이전트는 **"문제를 해결하기 위한 에이전트 팀과 워크플로우를 설계하는"** 에이전트입니다. 즉, 사용자가 고수준의 목표만 제시하면, 메타 에이전트가 스스로 필요한 에이전트들의 역할(`agent.md`)과 협력 방식(`workflow.md`)을 동적으로 생성하여 문제를 해결합니다. 이는 이 프로젝트의 로드맵에서 'Phase 3: 지침 생성 에이전트 개발'에 해당합니다.

이러한 고급 아키텍처의 구체적인 구현 예시는 [8장. 상황별 인스트럭션 설계 패턴 예제](08-practical.md)의 후반부 사례들에서 다시 한번 확인하게 될 것입니다.

## 참고 자료

- Hohpe, G., & Woolf, B. (2003). *Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions*. Addison-Wesley Professional.

---

[^1]: **핸드오프(Handoff):** 하나의 작업 단위(에이전트, 컴포넌트)에서 다른 작업 단위로 책임과 제어권, 그리고 관련 데이터를 전달하는 프로세스. 시스템의 각 부분이 원활하게 협력하기 위한 핵심적인 '연결' 과정이다.

[^2]: **엔터프라이즈 통합 패턴(Enterprise Integration Patterns):** 기업 환경에서 서로 다른 애플리케이션과 시스템들을 안정적이고 확장 가능하게 연동하기 위한 재사용 가능한 해결책들의 모음. 비동기 메시징 기반의 다양한 패턴을 제시하며, 현대적인 분산 시스템 설계에 큰 영향을 주었다.

[^3]: **파이프라인 패턴(Pipeline Pattern):** 여러 처리 단계를 순차적으로 연결하여, 각 단계가 이전 단계의 출력을 입력으로 받아 작업을 수행하는 구조. 데이터 처리 및 변환 작업에 널리 사용된다.

[^4]: **엑스포넨셜 백오프(Exponential Backoff):** 실패한 작업을 재시도할 때, 매번 시도 간의 시간 간격을 기하급수적으로 늘리는 알고리즘. 일시적인 과부하 상태에 있는 시스템이 스스로 회복할 시간을 주어, 연속적인 재시도로 인한 시스템 붕괴를 막는 데 효과적이다.
