# 7장. 처리 방법과 워크플로우 설계

**Part 2: 인스트럭션 시스템 설계와 평가**

**목적:** 개별 에이전트들을 유기적으로 연결하여, 복잡한 실제 업무를 안정적으로 자동화하는 워크플로우를 설계하는 방법을 배웁니다.

### 이 장에서 배우는 것
- 개별 에이전트를 넘어 워크플로우 설계가 필요한 이유.
- 워크플로우를 구성하는 핵심 요소(에이전트, 태스크, 핸드오프 등)에 대한 이해.
- 협력의 복잡도에 따른 다양한 워크플로우 아키텍처.
- 실패에 대비하고 시스템의 안정성을 높이는 설계 방법.
- 스스로를 개선하는 고급 아키텍처의 개념.

## 7.1 왜 워크플로우 설계가 필요한가?

5장과 6장을 통해 우리는 명확한 역할과 입/출력 명세를 가진 개별 전문가 에이전트를 만드는 법을 배웠습니다. 이는 마치 뛰어난 바이올리니스트, 첼리스트, 피아니스트를 각각 섭외한 것과 같습니다. 하지만 이들이 모여 아름다운 교향곡을 연주하게 하려면, 누가 언제 연주를 시작하고, 어떤 빠르기로 연주하며, 어떻게 서로 조화를 이룰지 지휘하는 '악보'와 '지휘자'가 필요합니다. **워크플로우 설계**는 바로 이 '악보'를 그리고 '지휘'의 규칙을 정하는 과정입니다.

### 7.1.1 복잡성 관리

'신규 기능 출시'와 같은 실제 업무는 코드 작성, 테스트, 문서 업데이트, 고객 공지 등 여러 단계와 다양한 전문성이 필요합니다. 이를 하나의 거대 에이전트에게 맡기는 것은 비효율적이고 실패 확률이 높습니다. 워크플로우 설계는 이 복잡한 과업을 각 에이전트가 맡을 수 있는 작은 태스크로 나누고, 전체 프로세스를 조율하여 복잡성을 관리 가능한 수준으로 유지합니다.

### 7.1.2 불안정한 핸드오프(Handoff)

에이전트 간의 작업 전달은 마치 릴레이 경주의 '바통 터치'와 같습니다. 앞선 주자가 다음 주자에게 바통을 제대로 전달하지 못하면(불안정한 핸드오프[^1]), 경기는 그대로 중단됩니다. 한 에이전트의 결과물이 다음 에이전트가 기대하는 입력 형식과 다르면, "Garbage In, Garbage Out" 문제가 에이전트 사이에서 발생하여 전체 라인이 멈춰버립니다. 워크플로우는 이 핸드오프 과정을 명확한 '계약'으로 정의하여, 시스템이 안정적으로 작동하도록 보장합니다.

### 7.1.3 연쇄 실패(Cascading Failures)

여러 에이전트가 사슬처럼 연결된 작업에서, 중간의 한 에이전트가 실패하면 전체 프로세스가 중단될 수 있습니다. 이는 마치 공연 중 한 배우가 실수를 했을 때, 아무런 대비책이 없다면 공연 전체가 엉망이 되는 것과 같습니다. 워크플로우 설계는 이러한 실패 상황을 미리 예측하고, 재시도나 대체 경로 같은 '컨틴전시 플랜(비상 계획)'을 마련하여 시스템의 안정성과 복원력을 높입니다.

## 7.2 워크플로우의 구성 요소

'워크플로우'는 공동의 목표를 달성하기 위해 여러 에이전트의 태스크를 조율하는 자동화된 프로세스입니다. 잘 설계된 워크플로우는 다음과 같은 핵심 구성 요소들을 명확히 정의해야 합니다.

- **에이전트 (Agents):** 워크플로우의 '일꾼'입니다. 5장에서 설계한 것처럼, 각자 명확한 역할, 책임, 제약을 가집니다.
- **태스크 (Tasks):** 에이전트가 수행하는 개별 작업 단위입니다. 4장의 **원자성(Atomicity)** 원칙에 따라, 태스크는 '성공' 또는 '실패'로 명확히 끝나는 최소 단위로 설계하는 것이 이상적입니다.
- **핸드오프 (Handoffs):** 한 태스크(에이전트)의 결과물을 다음 태스크(에이전트)에게 전달하는 방식과 데이터에 대한 약속(프로토콜)입니다.
- **트리거 (Triggers):** 워크플로우를 시작시키는 이벤트입니다.
- **실패 처리 규칙 (Failure Handling Rules):** 태스크 실패 시 대처 방법을 정의한 '컨틴전시 플랜'입니다.

## 7.3 기본 워크플로우 패턴

가장 단순한 형태의 워크플로우는 정해진 순서에 따라 작업을 처리하는 패턴들입니다.

- **파이프라인 패턴 (Pipeline Pattern)[^3]:** 가장 기본적인 순차 처리 구조(A → B → C)입니다. '오디오 파일 텍스트 변환 → 변환된 텍스트 요약 → 요약문 번역'과 같이, 이전 단계의 출력이 다음 단계의 입력으로 직접 이어지는 간단한 프로세스에 적합합니다.

- **생성-검증 패턴 (Generate-and-Validate Pattern):** 하나의 '생성 에이전트'가 초안을 만들면, 다른 '검증 에이전트'가 사실 여부, 품질 등을 검토하고 수정합니다. 결과물의 신뢰도를 높이는 데 매우 효과적입니다.

- **분기 패턴 (Routing Pattern):** 입력의 내용이나 조건에 따라 다음에 실행될 에이전트를 동적으로 결정하는 구조입니다. '라우터 에이전트'가 고객 문의를 분석하여 '기술 지원'은 개발팀 에이전트에게, '결제 문의'는 재무팀 에이전트에게 작업을 분배하는 방식입니다.

## 7.4 에이전트 협업의 핵심: 산출물 인터페이스

다양한 협업 모델을 살펴보기 전에, 모든 협업의 가장 기본이 되는 '소통 방식'을 정의해야 합니다. 에이전트들은 어떻게 서로의 작업을 인계받고, 진행 상황을 공유할까요? 그 해답은 **산출물(Artifact)**을 명확한 **인터페이스(Interface)**로 사용하는 데 있습니다.

산출물은 단순히 한 에이전트의 결과물이 아닙니다. 이는 워크플로우의 상태를 나타내고, 다음 에이전트의 행동을 결정하는 핵심적인 매개체입니다. 이 산출물은 두 가지 중요한 역할을 동시에 수행합니다.

### 7.4.1 산출물의 이중적 역할

**1. 작업의 연결고리 (Enabler for Collaboration)**

산출물은 에이전트 간의 '계약'입니다. A 에이전트의 산출물 형식과 B 에이전트의 입력 형식이 약속되어 있다면, 두 에이전트는 서로를 기다릴 필요 없이 독립적으로 개발하고 실행할 수 있습니다.

- **병렬/비동기 작업 활성화:** 아키텍트 에이전트가 "A는 `report.json`을, B는 `summary.md`를 만들라"고 지시하고, "C는 `report.json`과 `summary.md`가 모두 준비되면 그것들을 취합하여 최종 보고서를 만들라"고 계획을 세울 수 있습니다. A와 B는 서로의 작업이 끝날 때까지 기다릴 필요 없이 **병렬적**으로 작업을 수행할 수 있습니다. 산출물이라는 명확한 결과물이 있기에 가능한 일입니다.

**2. 실행의 기록 (Log and Trace)**

산출물은 그 자체로 '이전 단계에서 무슨 일이 있었는지'를 알려주는 명확한 **로그**가 됩니다.

- **순차적 작업의 투명성:** 파이프라인(A→B→C)에서 B 에이전트는 A가 남긴 산출물을 통해 A의 작업 결과를 정확히 파악하고 자신의 일을 시작할 수 있습니다.
- **디버깅 및 추적:** 워크플로우 중간에 문제가 생겼을 때, 각 단계의 산출물을 순서대로 살펴보는 것만으로 어느 에이전트에서 문제가 발생했는지 쉽게 추적할 수 있습니다. 이는 4장에서 강조한 **투명성 및 추적 가능성** 원칙을 시스템 수준에서 구현하는 방법입니다.

### 7.4.2 일반 사용자를 위한 산출물 설계 가이드

복잡한 기술 없이도, 일반 사용자나 개발자는 파일 기반의 간단한 규칙을 통해 효과적인 산출물 인터페이스를 설계할 수 있습니다.

- **파일 기반으로 소통하세요:** 에이전트가 자신의 작업 결과를 특정 폴더에 명확한 이름의 파일로 저장하게 하세요. (e.g., `01_data_analysis.json`, `02_draft_text.md`) 이는 가장 간단하고 직관적인 협업 방식입니다.
- **구조화된 데이터를 사용하세요:** 단순 텍스트보다는 `JSON`이나 `YAML` 형식을 사용하여, 데이터의 의미를 명확하게 전달하는 것이 좋습니다.
- **상태와 데이터를 함께 담으세요:** 산출물에는 결과 데이터뿐만 아니라, 작업의 성공 여부, 타임스탬프, 사용된 에이전트 버전 등 **메타데이터**를 함께 포함시키세요.

```json
// 예시: 01_data_analysis.json
{
  "metadata": {
    "agent_name": "data-analyzer-v2",
    "timestamp": "2025-10-03T10:00:00Z",
    "status": "success",
    "error_message": null
  },
  "data": {
    "user_growth": 0.15,
    "key_insights": [
      "20대 사용자의 재방문율이 높음",
      "푸시 알림을 통한 유입이 가장 효과적"
    ]
  }
}
```

이제, 이렇게 산출물을 통해 소통하는 것을 전제로, 에이전트들이 어떤 다양한 조직 구조를 형성할 수 있는지 다음 섹션에서 본격적으로 살펴보겠습니다.

## 7.5 다중 에이전트 협업 모델: 복잡도에 따른 분류

단순한 패턴을 넘어 여러 에이전트가 유기적으로 협력하는 구조를 만들려면, 에이전트의 수와 상호작용의 복잡도를 기준으로 모델을 발전시켜야 합니다.

### 7.5.1 복잡도 Level 1: 단위 업무 워크플로우

가장 기본적인 워크플로우는 단일 책임을 가진 업무를 여러 에이전트가 파이프라인 형태로 처리하는 것입니다.

- **구조:** A → B → C
- **설명:** 각 에이전트는 자신의 단계만 책임지며, 전체 워크플로우를 조율하는 별도의 관리자는 없습니다. 7.3절의 **파이프라인 패턴**이 대표적인 예입니다.
- **한계:** 미리 정해진 경로만 따를 수 있으며, 예외 상황이나 동적인 작업 분배가 어렵습니다.

### 7.5.2 복잡도 Level 2: 아키텍트-워커 모델

복잡성이 증가하면, 전체 작업을 조율하는 '지휘자'가 필요해집니다. 이것이 바로 아키텍트-워커 모델입니다.

- **구조:** 아키텍트 1명 → 워커 N명
- **설명:**
    - **아키텍트 에이전트:** 최종 목표를 입력받아, 이를 여러 개의 하위 태스크로 분해하고 계획을 수립합니다. 각 태스크를 어떤 워커에게 할당할지 결정하고, 전체 진행 상황을 감독합니다.
    - **워커 에이전트:** 아키텍트로부터 구체적인 단일 태스크를 할당받아 수행하고 결과를 보고합니다.
- **장점:** 중앙 지휘자가 있어 동적인 작업 할당과 병렬 처리가 가능해져 효율성이 크게 향상됩니다.

### 7.5.3 복잡도 Level 3: 계층적 조직과 재귀적 아키텍트-워커

매우 복잡한 문제(e.g., "신제품 출시")가 주어지면, 아키텍트 한 명이 모든 것을 관리하기 버거워집니다. 이때 아키텍트-워커 모델이 자기 자신을 반복하는 **재귀(Recursion)** 구조가 나타납니다. 이는 전통적인 기업의 **계층적 조직**과 유사합니다.

- **구조:** CEO → 본부장 → 팀장 → 팀원
- **설명:**
    1.  **최상위 아키텍트 (CEO):** 가장 추상적인 목표를 받습니다.
    2.  최상위 아키텍트는 자신이 직접 워커에게 일을 시키는 대신, 더 작은 책임을 맡는 **중간 관리자 (본부장)**들을 아키텍트로 임명합니다.
    3.  이때, 중간 관리자는 상위 아키텍트에게는 **'워커'**이지만, 자신의 팀원들에게는 **'아키텍트'** 역할을 하는 **역할 전환**이 일어납니다.
    4.  이러한 위임 과정이 계층적으로 반복되며, 가장 말단에 있는 '진짜' 워커들이 실제 단위 업무를 수행합니다.
- **특징:** 명확한 지휘 계통을 통해 복잡한 문제를 체계적으로 분해하고 관리할 수 있습니다.

### 7.5.4 복잡도 Level 4: 수평적 조직과 재귀적 아키텍트-워커

현대의 애자일 조직처럼, 여러 팀이 동등한 위치에서 협업하는 구조도 가능합니다. 여기서도 아키텍트-워커 모델은 재귀적으로 활용됩니다.

- **구조:** 여러 개의 독립적인 팀(Squad)들이 서로 협력하는 구조.
- **설명:**
    1.  전체 목표를 달성하기 위해 여러 전문 팀(e.g., 프론트엔드팀, 백엔드팀, 데이터팀)이 구성됩니다.
    2.  각 팀은 **팀 리더(아키텍트)**와 **팀원(워커)**으로 구성된 자체적인 아키텍트-워커 모델을 가집니다.
    3.  이 팀들은 상하 관계가 아닌, **수평적 관계**에서 서로 필요한 것을 요청하고 결과를 공유하며 협력합니다. (e.g., 프론트엔드팀이 백엔드팀에 API를 요청)
- **특징:** 각 팀의 전문성과 자율성을 극대화할 수 있으며, 변화에 유연하게 대응할 수 있습니다. 실제로는 계층적 구조와 수평적 구조가 결합된 **하이브리드 모델**이 가장 일반적입니다.

## 7.6 시스템 안정성 설계

워크플로우는 반드시 실패할 수 있다는 전제하에, 복원력을 설계해야 합니다.

### 7.6.1 견고한 핸드오프 설계
에이전트 간의 핸드오프는 워크플로우의 가장 취약한 지점 중 하나입니다. 6장에서 배운 구조화된 입/출력 설계를 '계약'으로 활용하여 핸드오프의 안정성을 보장해야 합니다.

- **표준화된 데이터 구조:** 모든 에이전트는 JSON Schema 등으로 명확히 정의된 데이터 구조로만 소통해야 합니다.
- **상태 정보 포함:** 데이터뿐만 아니라, 이전 태스크의 성공/실패 여부, 오류 코드 등 '메타데이터'를 함께 전달하여 다음 에이전트가 상황을 명확히 인지하고 대처하게 해야 합니다.

### 7.6.2 실패 및 복원력 설계
- **재시도 (Retry):** 일시적인 오류는 2~3회 자동 재시도를 구현합니다.
- **대체 경로 (Fallback):** 핵심 에이전트 실패 시, 더 단순한 대체 에이전트를 실행하거나 담당자에게 알림을 보냅니다.
- **모니터링 및 로깅:** 모든 태스크의 상태를 로그로 기록하여 문제 발생 시 원인을 신속하게 진단할 수 있어야 합니다.

## 7.7 실제 워크플로우 설계 예제

(기존의 '콘텐츠 제작 자동화' 및 '고객 지원 티켓 처리 자동화' 예제 내용이 여기에 위치합니다. 내용은 생략합니다.)

## 7.8 고급 아키텍처: 자기개선 시스템

이 책의 궁극적인 목표는 **'메타 에이전트(Meta Agent)'**를 설계하는 것입니다. 이는 에이전트 시스템이 스스로를 설계하고 개선하는 완전한 자율성을 의미하며, 다음과 같은 3단계 추상화 계층으로 이해할 수 있습니다.

1.  **Level 1: 실행 에이전트 (Execution Agents)**
    - **역할:** 실제 업무를 수행하는 모든 에이전트(워커, 매니저 등).
    - **목표:** 주어진 문제를 해결.

2.  **Level 2: 아키텍트 에이전트 (Architect Agent)**
    - **역할:** 실행 에이전트 팀과 그들의 워크플로우(`workflow.yaml`)를 설계하고 개선.
    - **목표:** 실행 시스템을 설계.

3.  **Level 3: 메타 에이전트 (Meta Agent)**
    - **역할:** 아키텍트 에이전트의 인스트럭션과 성능을 설계하고 개선.
    - **목표:** 아키텍트 에이전트를 설계.

일반 에이전트가 '문제'를 푼다면, 아키텍트는 '시스템'을 설계하고, 메타 에이전트는 '아키텍트'를 설계합니다. 이러한 고급 아키텍처는 10장에서 더 깊이 다룰 것입니다.

## 참고 자료

(기존 참고 자료 내용이 여기에 위치합니다. 내용은 생략합니다.)

---

[^1]: **핸드오프(Handoff):** 하나의 작업 단위에서 다른 작업 단위로 책임과 제어권, 데이터를 전달하는 프로세스.
[^2]: **엔터프라이즈 통합 패턴(Enterprise Integration Patterns):** 서로 다른 시스템들을 안정적으로 연동하기 위한 재사용 가능한 해결책 모음.
[^3]: **파이프라인 패턴(Pipeline Pattern):** 여러 처리 단계를 순차적으로 연결하여, 각 단계가 이전 단계의 출력을 입력으로 받아 작업을 수행하는 구조.
[^4]: **엑스포넨셜 백오프(Exponential Backoff):** 실패 시 재시도 간격을 기하급수적으로 늘려 시스템 과부하를 막는 알고리즘.
