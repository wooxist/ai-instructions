# 7.5장. 중간 규모 협업과 상태 관리

**Part 3: 워크플로우, 성능과 평가**

7장에서 파이프라인, 생성-검증, 라우팅 패턴을 배웠습니다. 이 패턴들은 2개 정도의 에이전트가 협력할 때 매우 효과적입니다. 하지만 실제 프로젝트에서는 더 많은 에이전트가 필요한 경우가 많습니다. 이번 장에서는 3-4개 에이전트가 협력하는 **중간 규모 협업**을 다루며, 작업 상태를 추적하고 파일을 체계적으로 관리하는 방법을 배웁니다.

## 7.5.1 복잡도의 진화: 언제 더 많은 에이전트가 필요한가?

### 협업 규모의 단계

에이전트 협업은 복잡도에 따라 세 단계로 나눌 수 있습니다:

| 규모 | 에이전트 수 | 적합한 작업 | 관리 복잡도 |
|------|-----------|-----------|-----------|
| **단순 협업** | 1-2개 | 단일 문서 작성, 간단한 검증 | 낮음 |
| **중간 협업** | 3-4개 | 콘텐츠 팀, 기본 워크플로우 | 중간 |
| **복잡 협업** | 5개 이상 | 다부서 협업, 대규모 프로젝트 | 높음 |

### 에이전트를 추가해야 하는 신호

다음과 같은 상황에서는 에이전트 수를 늘리는 것이 좋습니다:

1. **전문성 분리 필요**: 한 에이전트가 너무 많은 역할을 수행하고 있다면
   - 예: 작성 + 편집 + 발행을 한 에이전트가 담당 → 각각 독립 에이전트로 분리

2. **병렬 처리 기회**: 동시에 수행 가능한 작업이 있다면
   - 예: 이미지 생성과 텍스트 작성을 동시에 진행

3. **품질 관리 강화**: 여러 단계의 검증이 필요하다면
   - 예: 사실 확인 → 문법 검토 → 스타일 검토

4. **작업 흐름 복잡화**: 조건부 분기나 반복이 많아지면
   - 예: 검토 결과에 따라 다른 수정 방식 적용

**핵심 원칙**: 에이전트를 늘리는 것이 항상 좋은 것은 아닙니다. **필요한 만큼만, 명확한 역할을 가진** 에이전트를 추가하세요.

## 7.5.2 3-4개 에이전트 협업 패턴

실제 사례를 통해 중간 규모 협업을 살펴보겠습니다.

### 사례: 콘텐츠 팀 워크플로우

블로그 포스트를 발행하는 4단계 프로세스를 설계해봅시다:

```mermaid
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#1f77b4',
    'primaryTextColor': '#ffffff',
    'primaryBorderColor': '#1f77b4',
    'lineColor': '#6c757d',
    'background': 'transparent',
    'edgeLabelBackground': '#2ca02c'
  }
}}%%
graph LR
    A("작성 에이전트") --> B("검토 에이전트")
    B --> C("편집 에이전트")
    C --> D("발행 에이전트")

    %% 클래스 정의 및 적용
    classDef agent fill:#6f42c1,stroke:#6f42c1,color:#ffffff;
    class A,B,C,D agent;
```

**각 에이전트의 역할:**

1. **작성 에이전트**: 주제를 받아 초안 작성
   - 입력: `topic.txt`
   - 출력: `draft.md`

2. **검토 에이전트**: 사실 관계와 논리 흐름 확인
   - 입력: `draft.md`
   - 출력: `review_notes.json` (피드백 포함)

3. **편집 에이전트**: 피드백 반영 및 문법/스타일 개선
   - 입력: `draft.md`, `review_notes.json`
   - 출력: `edited.md`

4. **발행 에이전트**: 최종 포맷팅 및 메타데이터 추가
   - 입력: `edited.md`
   - 출력: `published.md`, `metadata.json`

### workflow.yaml 예시

```yaml
# workflow.yaml — 콘텐츠 팀 워크플로우
name: "블로그 포스트 발행 파이프라인"
workflow:
  - id: write
    agent: "작성 에이전트"
    input: "topic.txt"
    prompt: "주제 파일을 읽고 2,000단어 분량의 블로그 포스트 초안을 작성하세요."
    output: "draft.md"

  - id: review
    agent: "검토 에이전트"
    input: "draft.md"
    prompt: "초안의 사실 관계와 논리 흐름을 검토하고 피드백을 JSON으로 출력하세요."
    output: "review_notes.json"

  - id: edit
    agent: "편집 에이전트"
    input: ["draft.md", "review_notes.json"]
    prompt: "검토 피드백을 반영하여 초안을 개선하고 문법/스타일을 교정하세요."
    output: "edited.md"

  - id: publish
    agent: "발행 에이전트"
    input: "edited.md"
    prompt: "최종 포맷팅을 적용하고 메타데이터(제목, 태그, 작성일)를 생성하세요."
    output: ["published.md", "metadata.json"]
```

**하이브리드 패턴 활용**: 이 워크플로우는 **파이프라인(순차 처리)** + **생성-검증(검토-편집 루프)** 패턴을 결합한 것입니다.

## 7.5.3 파일 기반 상태 관리 입문

에이전트가 3-4개로 늘어나면, "지금 어느 단계까지 진행되었는가?"를 추적하는 것이 중요해집니다.

### 왜 상태 추적이 필요한가?

1. **진행 상황 파악**: 어떤 단계가 완료되었고, 어떤 단계가 남았는지
2. **에러 복구**: 중간에 실패했을 때 어디서부터 다시 시작할지
3. **병렬 실행**: 여러 작업이 동시에 진행될 때 각각의 상태 구분

### 간단한 상태 파일: status.json

가장 기본적인 상태 추적 방법은 **하나의 JSON 파일**에 현재 상태를 기록하는 것입니다.

```json
{
  "workflow_id": "blog-post-001",
  "current_step": "edit",
  "status": "in_progress",
  "steps_completed": ["write", "review"],
  "steps_remaining": ["edit", "publish"],
  "last_updated": "2025-10-06T14:30:00Z"
}
```

**필드 설명:**
- `current_step`: 현재 진행 중인 단계
- `status`: 전체 워크플로우 상태 (`pending`, `in_progress`, `completed`, `failed`)
- `steps_completed`: 완료된 단계 목록
- `steps_remaining`: 남은 단계 목록

### 에이전트가 상태를 읽고 쓰는 방법

각 에이전트는 작업 시작 전 `status.json`을 읽어 현재 상태를 확인하고, 작업 완료 후 상태를 업데이트합니다.

**편집 에이전트 인스트럭션 예시:**
```markdown
당신은 편집 에이전트입니다.

1. status.json 파일을 읽어 current_step이 "edit"인지 확인하세요.
2. draft.md와 review_notes.json을 읽어 피드백을 반영한 편집본을 작성하세요.
3. 작업 완료 후 status.json을 다음과 같이 업데이트하세요:
   - current_step: "publish"
   - steps_completed에 "edit" 추가
   - steps_remaining에서 "edit" 제거
   - last_updated: 현재 시각
```

## 7.5.4 기본 디렉토리 구조 설계

파일이 10개 이상 생기면 단일 디렉토리로는 관리가 어려워집니다. 체계적인 폴더 구조가 필요합니다.

### 작업별 폴더 분리

같은 워크플로우를 여러 번 실행하는 경우(예: 여러 블로그 포스트), 각 작업마다 독립적인 폴더를 만듭니다.

```
project/
├── tasks/
│   ├── task-001/          # 첫 번째 블로그 포스트
│   │   ├── status.json
│   │   ├── topic.txt
│   │   ├── draft.md
│   │   ├── review_notes.json
│   │   ├── edited.md
│   │   └── published.md
│   │
│   └── task-002/          # 두 번째 블로그 포스트
│       ├── status.json
│       ├── topic.txt
│       └── ...
│
├── shared/
│   ├── templates/         # 공통 템플릿
│   │   └── blog_template.md
│   └── style_guide.md     # 작성 가이드라인
│
└── workflow.yaml          # 워크플로우 정의
```

**설계 원칙:**
- **격리(Isolation)**: 각 작업은 독립적인 폴더에 보관
- **공유(Sharing)**: 모든 작업이 사용하는 자원은 `/shared/`에 배치
- **명명 규칙(Naming)**: `task-{번호}` 형식으로 일관되게 명명

### 디렉토리 구조의 장점

1. **충돌 방지**: 여러 작업이 동시에 진행되어도 파일이 섞이지 않음
2. **추적 용이**: 특정 작업의 모든 파일을 한 곳에서 확인
3. **정리 편의**: 완료된 작업 폴더를 아카이브하거나 삭제하기 쉬움

## 7.5.5 산출물 표준화: 텍스트에서 JSON으로

에이전트 간 소통이 복잡해질수록, **구조화된 데이터 형식**이 중요해집니다.

### 왜 JSON이 필요한가?

**텍스트 파일의 한계:**
```
검토 결과: 불합격
이유: 3문단의 통계 수치가 정확하지 않음
수정 필요 부분: 3문단, 7문단
```
→ 다음 에이전트가 이 텍스트를 "파싱"하여 이해해야 함 (어려움)

**JSON의 장점:**
```json
{
  "result": "fail",
  "reason": "3문단의 통계 수치가 정확하지 않음",
  "sections_to_revise": [3, 7],
  "severity": "high"
}
```
→ 다음 에이전트가 `result` 필드만 확인하면 즉시 판단 가능

### 표준 산출물 형식 설계

모든 에이전트의 산출물에 공통 구조를 적용하면 일관성이 높아집니다.

```json
{
  "task_id": "task-001",
  "agent": "review-agent-v2",
  "status": "completed",
  "timestamp": "2025-10-06T14:45:00Z",
  "output": {
    // 에이전트별 실제 결과 데이터
    "result": "pass",
    "feedback": "논리 흐름이 명확하며 사실 관계 확인 완료"
  }
}
```

**공통 필드:**
- `task_id`: 어떤 작업의 결과인가?
- `agent`: 어떤 에이전트가 생성했는가?
- `status`: 성공했는가? (`completed`, `failed`)
- `timestamp`: 언제 생성되었는가?
- `output`: 실제 결과 데이터 (에이전트마다 다름)

### 에이전트 인스트럭션에 JSON 형식 명시

```markdown
당신은 검토 에이전트입니다.

검토 완료 후 다음 JSON 형식으로 결과를 출력하세요:

{
  "task_id": "작업 ID",
  "agent": "review-agent-v2",
  "status": "completed" 또는 "failed",
  "timestamp": "현재 시각 (ISO 8601)",
  "output": {
    "result": "pass" 또는 "fail",
    "feedback": "검토 의견 (문자열)",
    "sections_to_revise": [수정 필요한 문단 번호 배열]
  }
}

파일명: review_notes.json
```

## 7.5.6 에러 처리와 재시도 전략

중간 규모 워크플로우에서는 에이전트 실패가 자주 발생할 수 있습니다. 기본적인 에러 처리를 설계해야 합니다.

### 실패 시나리오

1. **타임아웃**: 에이전트가 응답하지 않음
2. **형식 오류**: JSON 출력이 잘못됨
3. **품질 불합격**: 검증 기준을 통과하지 못함

### workflow.yaml에 재시도 설정 추가

```yaml
name: "블로그 포스트 발행 파이프라인 (재시도 포함)"
workflow:
  - id: write
    agent: "작성 에이전트"
    input: "topic.txt"
    prompt: "주제 파일을 읽고 블로그 포스트 초안을 작성하세요."
    output: "draft.md"
    max_retries: 3              # 최대 3회 재시도
    timeout: 300                # 5분 타임아웃

  - id: review
    agent: "검토 에이전트"
    input: "draft.md"
    prompt: "초안을 검토하고 피드백을 JSON으로 출력하세요."
    output: "review_notes.json"
    max_retries: 2
    on_failure: "skip"          # 실패 시 건너뛰고 계속 진행
```

**재시도 정책:**
- `max_retries`: 실패 시 몇 번까지 재시도할 것인가?
- `timeout`: 각 시도당 최대 대기 시간
- `on_failure`: 재시도 실패 시 어떻게 할 것인가?
  - `abort`: 전체 워크플로우 중단
  - `skip`: 해당 단계 건너뛰고 계속 진행
  - `fallback`: 대체 에이전트로 시도

### 실패 로그 기록

에이전트가 실패하면 상세한 로그를 남겨야 나중에 문제를 진단할 수 있습니다.

```json
// error.log
{
  "task_id": "task-001",
  "step": "write",
  "agent": "writer-agent-v1",
  "error_type": "timeout",
  "error_message": "5분 내에 응답하지 않음",
  "retry_count": 3,
  "timestamp": "2025-10-06T15:00:00Z"
}
```

## 7.5.7 다음 단계로: 10장 준비하기

이번 장에서 배운 중간 규모 협업의 핵심 개념들을 정리해봅시다.

### 지금까지 배운 것

| 개념 | 7장 (단순 협업) | 7.5장 (중간 협업) | 10장 (복잡 협업) |
|------|---------------|-----------------|----------------|
| 에이전트 수 | 1-2개 | 3-4개 | 6개 이상 |
| 상태 관리 | 없음 | status.json | _job_log.json |
| 파일 구조 | 단일 디렉토리 | /tasks/task-{id}/ | /agents, /workflows, /jobs |
| 산출물 형식 | 텍스트 | JSON (기본) | JSON + 메타데이터 |
| 관리 주체 | 인간 | 인간 | 아키텍트 에이전트 |

### 10장에서 배울 핵심 차이

**가장 큰 변화: "인간이 직접 관리" → "아키텍트가 자동 관리"**

- **7.5장까지**: 인간이 workflow.yaml을 작성하고 각 작업을 시작
- **10장부터**: **아키텍트 에이전트**가 상황을 판단하고 필요한 워커를 동적으로 생성

**계층적 조직 구조:**
- **메타 에이전트**: 워커 에이전트를 생성하는 "공장"
- **아키텍트 에이전트**: 프로젝트를 총괄하고 워커에게 작업 할당
- **워커 에이전트**: 실제 작업 수행 (우리가 7.5장에서 다룬 에이전트들)

**이번 장은 10장의 "준비 운동"입니다.** 상태 관리, 디렉토리 구조, JSON 산출물 같은 기본 개념을 익혔으니, 이제 이를 대규모로 확장하는 방법을 배울 준비가 되었습니다.

---

## 실습 체크리스트
> 참고: 심화 과제는 [실습 과제 모음](practice-guide.md)을 참고하세요.

### 이 장을 완료하셨다면 다음을 확인하세요:

**개념 이해**
- [ ] 에이전트를 추가해야 하는 4가지 신호를 설명할 수 있다
- [ ] 단순/중간/복잡 협업의 차이를 이해한다
- [ ] status.json을 통한 상태 추적의 필요성을 안다

**실습 능력**
- [ ] 3-4개 에이전트를 활용한 워크플로우를 설계할 수 있다
- [ ] `/tasks/task-{id}/` 구조로 디렉토리를 설계할 수 있다
- [ ] JSON 형식의 산출물을 정의할 수 있다
- [ ] workflow.yaml에 재시도 정책을 추가할 수 있다

**적용 및 활용**
- [ ] 7장 패턴과 7.5장 패턴 중 어느 것이 적합한지 판단할 수 있다
- [ ] 10장의 계층적 구조가 필요한 시점을 예상할 수 있다

---

## 실습 과제

### 과제 1: 중간 규모 워크플로우 설계하기 🌿

**목표:** 자신의 업무에서 3-4단계로 나눌 수 있는 프로세스를 찾아 워크플로우 설계

**작성 내용:**
1. 프로세스 선택 및 단계 정의
   - 예: 보고서 작성 → 데이터 분석 → 차트 생성 → 초안 작성 → 검토
2. 각 에이전트의 역할과 책임
   - 입력: 어떤 파일을 읽는가?
   - 출력: 어떤 파일을 생성하는가?
3. workflow.yaml 초안 작성 (재시도 정책 포함)
4. 다이어그램 (Mermaid 또는 손그림)

**평가 기준:**
- 각 에이전트의 역할이 명확하게 분리되어 있는가?
- 입출력이 다음 단계와 자연스럽게 연결되는가?
- 재시도 정책이 적절하게 설정되어 있는가?

---

### 과제 2: 상태 추적 시스템 구축하기 🌿

**목표:** status.json으로 워크플로우 상태를 추적하는 시스템 설계

**작성 내용:**
1. 과제 1의 워크플로우에 대한 status.json 초기 상태
   ```json
   {
     "workflow_id": "...",
     "current_step": "...",
     "status": "pending",
     "steps_completed": [],
     "steps_remaining": ["step1", "step2", ...]
   }
   ```
2. 각 단계 완료 후 status.json 업데이트 시나리오
   - 1단계 완료 후 상태
   - 2단계 완료 후 상태
   - 전체 완료 후 상태
3. 에이전트 인스트럭션에 "status.json 읽기 및 업데이트" 지시 추가

**평가 기준:**
- 모든 단계에서 status.json이 정확하게 업데이트되는가?
- 에이전트가 status.json을 읽고 현재 상태를 확인하는가?

---

### 과제 3: 디렉토리 구조 설계 및 산출물 표준화 🌿

**목표:** 여러 작업을 동시에 관리할 수 있는 파일 구조 설계

**작성 내용:**
1. 과제 1의 워크플로우를 3번 실행한다고 가정하고 디렉토리 구조 설계
   ```
   project/
   ├── tasks/
   │   ├── task-001/
   │   ├── task-002/
   │   └── task-003/
   ├── shared/
   └── workflow.yaml
   ```
2. 각 에이전트의 산출물을 표준 JSON 형식으로 정의
   ```json
   {
     "task_id": "...",
     "agent": "...",
     "status": "...",
     "timestamp": "...",
     "output": { ... }
   }
   ```
3. 하나의 작업(task-001)에 대해 모든 단계의 산출물 샘플 작성

**평가 기준:**
- 디렉토리 구조가 격리/공유/명명 규칙을 따르는가?
- JSON 산출물이 일관된 형식을 가지는가?
- 다음 에이전트가 이전 산출물을 쉽게 사용할 수 있는가?

---

### 과제 4: 에러 처리 시나리오 작성하기 🌿

**목표:** 실패 상황에 대비한 재시도 및 로깅 전략 수립

**작성 내용:**
1. 과제 1의 워크플로우에서 발생 가능한 실패 시나리오 3가지
   - 예: 데이터 분석 에이전트 타임아웃, JSON 형식 오류 등
2. 각 시나리오에 대한 재시도 정책
   - max_retries, timeout, on_failure 설정
3. error.log 샘플 (실패 시나리오별로)

**평가 기준:**
- 실패 시나리오가 현실적인가?
- 재시도 정책이 각 시나리오에 적절한가?
- error.log가 문제 진단에 충분한 정보를 담고 있는가?

---

### 심화 과제 (선택) 💎

**과제 5: 7장 패턴과 7.5장 패턴 비교 분석**
- 동일한 업무를 7장 방식(2개 에이전트)과 7.5장 방식(4개 에이전트)으로 각각 설계
- 두 방식의 장단점 비교 (품질, 속도, 유지보수성)
- 어떤 상황에서 어느 방식이 적합한지 의사결정 기준 수립

**과제 6: 10장 미리보기 - 간단한 아키텍트 개념 적용**
- 과제 1의 워크플로우에 "아키텍트 에이전트" 역할 추가
- 아키텍트가 상황에 따라 다른 워커를 선택하는 로직 설계
- 10장에서 배울 계층 구조의 기초 체험

---

**다음 장 예고:**  
8장에서는 에이전트의 **성능을 측정하고 최적화**하는 방법을 배웁니다. 품질, 비용, 속도 사이의 균형을 어떻게 맞출 것인가? 실제 벤치마킹과 개선 전략을 다룹니다.
