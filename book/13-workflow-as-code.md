# 13장. 도메인 특화 언어(DSL) 설계: AI와 소통하는 우리만의 언어

**Part 3: 인스트럭션 시스템의 확장과 운영**

**목적:**
- 도메인 특화 언어(Domain-Specific Language, DSL)의 기본 개념을 이해합니다.
- 왜 AI 에이전트 시스템을 위해 우리만의 언어(DSL)를 설계해야 하는지 그 필요성을 배웁니다.
- YAML과 마크다운을 조합하여, 사람이 읽기 쉽고 기계가 처리하기 쉬운 실용적인 DSL을 설계하는 방법을 학습합니다.

---

## 13.1 도메인 특화 언어(DSL)란 무엇인가?

**도메인 특화 언어(Domain-Specific Language, DSL)**는 말 그대로 '특정 영역(Domain)의 문제를 해결하는 데 특화된 컴퓨터 언어'입니다. 이는 파이썬(Python)이나 자바(Java)처럼 어떤 문제든 해결할 수 있는 '범용 언어(General-Purpose Language, GPL)'와는 다른 개념입니다.

비유하자면, 범용 언어는 어떤 요리든 만들 수 있는 전문가용 주방과 같습니다. 다양한 도구와 재료가 있지만, 이를 제대로 사용하려면 전문적인 지식과 경험이 필요합니다. 반면, DSL은 '캡슐 커피 머신'과 같습니다. 커피를 내린다는 특정 목적에 완벽하게 맞춰져 있어, 누구나 버튼 몇 번만 누르면 쉽고 일관되게 맛있는 커피를 만들 수 있습니다.

우리에게 익숙한 DSL의 예시는 다음과 같습니다.

- **HTML:** 웹 페이지의 '구조'를 표현하는 데 특화된 언어입니다. 우리는 HTML로 게임을 만들지는 않지만, 웹 페이지를 만드는 데는 이보다 더 좋은 언어가 없습니다.
- **SQL:** 데이터베이스에 데이터를 '요청'하는 데 특화된 언어입니다. `SELECT * FROM users WHERE age > 30;` 라는 구문은 "30세 이상인 모든 사용자의 정보를 보여줘"라는 명확한 의도를 표현합니다.
- **CSS:** 웹 페이지의 '스타일'을 꾸미는 데 특화된 언어입니다.

이 책에서 우리가 `workflow.yaml`을 통해 정의하는 언어 역시, **'AI 에이전트들의 협업 방식을 정의'**하는 데 특화된 우리만의 DSL입니다.

## 13.2 왜 우리만의 언어(DSL)가 필요한가?

그렇다면 왜 복잡하게 우리만의 언어를 만들어야 할까요? 그냥 파이썬 같은 범용 언어로 모든 것을 처리하면 안 될까요? 특히 이 책의 핵심 독자인 '일반 사용자'에게 DSL이 필요한 이유는 다음과 같습니다.

### 1. 복잡성 추상화 (Hiding Complexity)

가장 큰 이유는 **복잡한 내부 구현을 감추고, 사용자가 자신의 '의도'에만 집중하게 만들기 위함**입니다.

예를 들어, 10장에서 본 `type: parallel`이라는 한 줄의 코드를 생각해 봅시다. 만약 이를 범용 언어로 직접 구현하려면, 여러 에이전트를 동시에 실행하고(멀티스레딩 또는 비동기 처리), 모든 작업이 끝날 때까지 기다렸다가, 그 결과들을 다시 하나로 합치는 복잡한 코드를 작성해야 합니다.

하지만 DSL을 사용하면, 사용자는 그저 "이 단계들을 동시에 실행해줘"라는 의도만 `type: parallel`로 선언하면 됩니다. 복잡한 실행 과정은 DSL을 해석하는 '워크플로우 엔진'이 알아서 처리해 줍니다. 이는 마치 자동차 운전자가 엔진의 원리를 몰라도 운전할 수 있는 것과 같습니다.

### 2. 인간과 기계 모두를 위한 공용어 (Human & Machine Readable)

잘 설계된 DSL은 **사람이 읽고 이해하기 쉬우면서도, 동시에 기계가 정확하게 해석하여 실행할 수 있는** 이중의 장점을 가집니다.

- **사람을 위해:** `workflow.yaml`은 프로젝트의 전체 흐름을 보여주는 '업무 계획서'나 '설계도' 역할을 합니다. 개발자가 아니더라도 기획자, 마케터, 매니저 등 누구나 파일을 열어보고 "아, 재무팀의 보고서가 나와야 마케팅팀의 작업이 시작되는구나"라고 쉽게 이해할 수 있습니다. 즉, DSL은 팀원 간의 소통과 협업을 위한 훌륭한 '공용어'가 됩니다.

- **기계를 위해:** YAML 형식은 기계가 파싱(해석)하고 검증하기에 매우 용이한 구조입니다. 워크플로우 엔진은 이 파일을 읽어, 각 단계가 유효한지, 필요한 입력값은 모두 있는지 등을 확인하고 자동화된 프로세스를 실행할 수 있습니다.

### 3. 의도의 명확한 표현 (Clear Expression of Intent)

범용 언어로 작성된 코드는 '어떻게(How)' 동작하는지는 보여주지만, '왜(Why)' 그렇게 하는지에 대한 '의도'는 숨겨져 있는 경우가 많습니다. 반면, DSL은 사용자가 자신의 의도를 명확하게 표현하도록 유도합니다.

- `type: human_in_the_loop`: "이 단계는 위험하니, 반드시 사람의 승인이 필요하다"는 의도를 명확히 합니다.
- `type: handoff`: "여기까지가 우리 팀의 책임이고, 이제부터는 다른 팀의 책임이다"라는 조직 간의 업무 경계를 명확히 합니다.
- `retry: 3`: "이 작업은 가끔 실패할 수 있으니, 3번까지는 다시 시도해봐도 괜찮다"는 실패 처리 의도를 명확히 합니다.

이처럼 의도가 명시적으로 드러나면, 다른 사람이 워크플로우를 유지보수하거나 인수인계받을 때 훨씬 더 쉽고 안전하게 시스템을 이해할 수 있습니다.

### 4. 안전성과 제약 (Safety through Constraints)

DSL은 특정 도메인에 필요한 기능만 제공하고, 그 외의 위험한 행동은 원천적으로 '제약'함으로써 시스템의 안정성을 높입니다.

범용 언어는 자유도가 높은 만큼, 실수로 시스템의 중요 파일을 삭제하거나 무한 루프에 빠지는 등의 위험한 코드를 작성할 가능성도 열려 있습니다.

하지만 우리가 설계한 `workflow.yaml` DSL에서는 `agent`, `inputs`, `outputs` 등 미리 약속된 키워드만 사용할 수 있습니다. 만약 사용자가 `delete_all_files: true`와 같은 임의의 명령어를 추가하더라도, 워크플로우 엔진은 이를 알 수 없는 명령어로 인지하고 실행을 거부할 것입니다. 이러한 '제약'은 사용자를 실수로부터 보호하는 안전장치(Guardrail) 역할을 합니다.

다음 절에서는 이러한 원칙을 바탕으로, YAML과 마크다운을 조합하여 실용적인 워크플로우 DSL을 어떻게 설계하고 구현하는지 구체적으로 알아보겠습니다.

## 참고 자료

- Fowler, M. (2010). *Domain-Specific Languages*. Addison-Wesley Professional.
- Parr, T. (2009). *Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages*. Pragmatic Bookshelf.
