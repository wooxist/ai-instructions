# 6장. 입력과 출력 설계

**Part 2: 설계 원칙과 구성 요소**

**목적:** AI에게 전달할 데이터(입력)와 받아야 할 결과물(출력)의 명확한 입·출력 명세를 설계하여, 예측 가능하고 일관된 결과물을 얻는 방법을 배웁니다.

### 이 장에서 배우는 것
- 입력과 출력 설계가 왜 중요한지 이해합니다. (Garbage In, Garbage Out)
- 입력과 출력을 명세화하는 구체적인 구성 요소를 배웁니다.
- 산출물 중심 원칙에 기반한 입력/출력 설계 기법(구조화, Few-shot 등)을 익힙니다.
- 사용자의 의도가 모호할 때 AI가 동적으로 명세를 구체화하는 '의도 확인 루프'를 배웁니다.

## 6.1 왜 입력과 출력 설계가 중요한가?

5장에서 우리는 복잡한 문제를 해결하기 위해 단일 책임을 가진 전문가 에이전트들을 설계하는 법을 배웠습니다. 하지만 아무리 뛰어난 전문가라도, 작업에 필요한 '재료(입력)'가 잘못되거나 만들어야 할 '완성품(출력)'에 대한 정의가 모호하다면 제대로 된 결과물을 낼 수 없습니다. 입력과 출력 설계는 바로 이 '재료'와 '완성품'에 대한 명확한 약속, 즉 **명세(Specification)**를 만드는 과정입니다.

### 6.1.1 "Garbage In, Garbage Out": 모호한 입력의 함정

컴퓨터 과학의 오랜 격언인 "쓰레기를 넣으면 쓰레기가 나온다(Garbage In, Garbage Out)[^1]"는 AI 시대에 더욱 중요해졌습니다. AI에게 모호하거나 잘못된 입력을 주면 다음과 같은 문제가 발생합니다.

- **잘못된 가정:** AI는 컨텍스트가 부족하면 스스로 가정을 만들어냅니다. "보고서를 요약해줘"라는 지시에 대상 독자를 명시하지 않으면, AI는 독자를 기술 전문가로 가정하고 어려운 용어로 가득 찬 요약문을 만들 수 있습니다.
- **잘못된 데이터 작업:** 사용해야 할 데이터의 출처나 범위를 명확히 하지 않으면, AI는 엉뚱한 데이터를 분석하거나 오래된 정보를 사용하여 사실과 다른 결과를 도출할 수 있습니다.
- **낮은 품질의 결과:** 입력 데이터에 노이즈가 많거나 정제되지 않은 상태라면, AI는 그 노이즈까지 학습하여 결과물의 품질이 저하됩니다.

### 6.1.2 예측 불가능한 출력의 문제

출력에 대한 명확한 명세가 없다면, AI는 자유롭게 결과를 '창작'합니다. 이는 창의적인 아이디어를 얻을 때는 유용할 수 있지만, 여러 에이전트가 협력하는 자동화 시스템을 구축할 때는 심각한 문제를 야기합니다.

- **일관성 부재:** 동일한 작업을 요청해도 매번 다른 형식(줄글, 목록, 표 등)과 다른 구조로 결과물을 생성하여, 결과의 일관성을 보장할 수 없습니다.
- **후속 처리의 어려움:** 한 에이전트의 출력을 다른 에이전트의 입력으로 사용해야 하는 워크플로우에서, 출력 형식이 비정형적이면 후속 에이전트가 정보를 파싱(parsing)[^4]하고 처리하는 데 실패하게 됩니다. 이는 전체 **워크플로우(Workflow)**의 중단으로 이어지며, 에이전트 간의 안정적인 **협업**을 불가능하게 만듭니다.
- **검증의 어려움:** 정해진 형식이 없으면 결과물이 요구사항을 충족했는지 자동으로 검증하기가 매우 어렵습니다.

## 6.2 무엇을 설계해야 하는가?: 입력과 출력의 명세화

이러한 문제를 해결하기 위해, 우리는 에이전트가 상호작용할 데이터와 결과물에 대한 명확한 '명세(Specification)'를 설계해야 합니다. 이는 에이전트의 행동을 제어하는 가장 확실한 방법입니다.

### 6.2.1 입력 명세(Input Specification)

입력 명세는 AI에게 제공할 '재료'의 목록과 사양을 정의하는 것입니다.

- **컨텍스트 (Context):** 작업의 최종 목표, 결과물의 예상 독자, 관련 배경 정보 등 작업의 맥락을 제공합니다.
- **데이터 (Data):** AI가 사용해야 할 데이터의 출처(파일, URL, API 등), 형식(텍스트, JSON, CSV 등), 그리고 데이터의 스키마(필드, 타입 등)를 명확히 지정합니다.
- **전제 조건 (Pre-conditions):** "이 분석은 지난달 유료 사용자만을 대상으로 한다"와 같이, 작업이 수행되어야 할 기본 가정이나 범위를 명시합니다.
- **도메인 지식 (Domain Knowledge):** 특정 전문 분야의 작업을 수행할 때, AI가 참고해야 할 용어집, 핵심 개념, 관련 문서 등을 제공하여 품질을 높입니다.

### 6.2.2 출력 명세(Output Specification)

출력 명세는 AI가 만들어내야 할 '완성품'의 모습을 구체적으로 정의하는 것입니다.

- **형식 (Format):** JSON, YAML, 마크다운 표, 불릿 리스트 등 기계가 처리하기 쉽거나(machine-readable) 사람이 읽기 쉬운(human-readable) 형식을 지정합니다.
- **구조 (Structure):** 출력물에 포함되어야 할 필수 항목, 각 항목의 데이터 타입, 그리고 항목들의 순서 등을 스키마(Schema)로 정의합니다.
- **제약 조건 (Constraints):** "요약은 200단어 미만", "톤앤매너는 공식적이고 정중하게" 등 결과물이 지켜야 할 추가적인 규칙을 명시합니다.
- **성공 기준 (Success Criteria):** "주요 불만사항 3가지를 반드시 포함해야 한다"와 같이, 어떤 결과물이 '좋은 결과물'인지를 판단할 수 있는 기준을 제공합니다.

## 6.3 어떻게 설계하는가?: 결과물 중심 접근법과 구체적 기법

효과적인 입력과 출력 설계는 4장의 [산출물 중심(Output-Driven)](glossary.md#산출물-중심-output-driven) 원칙을 따릅니다. 즉, 최종적으로 얻고 싶은 '출력'을 먼저 명확하게 정의하고, 그 출력을 만드는 데 필요한 '입력'을 역으로 설계하는 것이 가장 효율적입니다.

### 6.3.1 출력 설계 기법

- **구조화된 형식 강제:** 가장 기본적이면서 강력한 기법입니다. 이는 마치 회사에서 보고서를 제출할 때 정해진 양식(템플릿)에 맞춰 작성하도록 하는 것과 같습니다. AI가 자유롭게 서술하게 두는 대신, `JSON`이나 `YAML`과 같은 구조화된 형식으로 답변하도록 강제하면, 기계가 그 결과를 자동으로 처리하기 매우 쉬워집니다. 특히 [JSON Schema](glossary.md#json-schema)[^2]를 함께 제공하면, AI는 스키마에 정의된 필드와 데이터 타입에 맞춰 정확하게 결과물을 생성합니다. 이는 에이전트 간의 데이터 교환 시 안정성을 보장하는 핵심입니다.

  > 예시: 티켓 분류 결과물의 JSON Schema
  >
  > ```json
  > {
  >   "$schema": "https://json-schema.org/draft/2020-12/schema",
  >   "$id": "https://example.com/schemas/ticket-classification.json",
  >   "title": "TicketClassification",
  >   "type": "object",
  >   "additionalProperties": false,
  >   "properties": {
  >     "ticket_id": { "type": "string" },
  >     "priority": { "type": "string", "enum": ["high", "medium", "low"] },
  >     "category": { "type": "string", "examples": ["payment", "bug", "general"] },
  >     "urgency_score": { "type": "integer", "minimum": 1, "maximum": 10 }
  >   },
  >   "required": ["ticket_id", "priority", "category", "urgency_score"],
  >   "examples": [
  >     {
  >       "ticket_id": "T-001",
  >       "priority": "high",
  >       "category": "payment",
  >       "urgency_score": 9
  >     }
  >   ]
  > }
  > ```
- **Few-Shot 예시 제공:** 백 마디 설명보다 한두 개의 좋은 예시가 더 효과적일 수 있습니다. 인스트럭션 내에 우리가 원하는 결과물의 구체적인 예시(입력-출력 쌍)를 1~2개 포함하면, AI는 그 패턴을 학습하여 유사한 형태로 결과물을 생성합니다. 이를 '퓨샷(Few-shot) 프롬프팅'[^3]이라고 합니다.
- **성공 기준 및 평가 지표 명시:** "이 요약문의 품질은 다음 3가지 기준으로 평가됩니다: 1) 핵심 내용 포함 여부, 2) 300단어 미만, 3) 중학생도 이해할 수 있는 평이한 언어 사용."과 같이 평가 기준을 명시하면, AI는 스스로 결과물을 개선하며 기준을 맞추려고 노력합니다.

> **예시: [1단계] 원하는 번역 결과물(출력)을 먼저 정의하기**
>
> 단순한 번역문(string) 대신, 작업의 메타데이터를 포함하는 JSON 객체로 결과물을 받도록 먼저 명확히 정의합니다.
>
> ```json
> {
>   "original_text": "The quick brown fox jumps over the lazy dog.",
>   "translated_text": "날쌘 갈색 여우가 게으른 개를 뛰어넘는다.",
>   "style": "poetic",
>   "explanation": "운율감을 살리기 위해 '날쌘'과 같은 형용사를 사용하고, 전체적으로 생동감 있는 어조를 유지했습니다."
> }
> ```
> 이렇게 원하는 출력 형식을 먼저 정의하면, 다음 단계에서 어떤 입력이 필요한지 명확해집니다.

### 6.3.2 입력 설계 기법

- **체계적인 컨텍스트 제공:** 컨텍스트를 단순히 나열하기보다, `## 최종 목표`, `## 대상 독자`, `## 참고 자료` 와 같이 마크다운 헤더를 사용해 구조적으로 제공하면, AI는 각 정보의 역할을 더 명확하게 파악합니다.
- **데이터 전처리 및 정제:** AI에게 데이터를 전달하기 전에, 관련 없는 정보를 제거하거나 노이즈를 줄이는 전처리 과정을 거치는 것이 좋습니다. 이는 AI가 작업의 핵심에 더 집중하고, 적은 토큰으로 더 높은 품질의 결과를 얻게 해줍니다.

> **예시: [2단계] 정의된 출력을 만들기 위한 입력 설계하기**
>
> **나쁜 입력:** "이 문장 번역해줘: 'The quick brown fox jumps over the lazy dog.' 대상 언어는 한국어야. 좀 더 시적으로." (→ 어떤 결과가 나올지 예측하기 어렵고, 후속 처리가 불가능합니다.)
>
> **좋은 입력:** 6.3.1에서 정의한 JSON 출력을 생성하도록, 모든 요구사항을 구조화하여 명확히 지시합니다.
>
```markdown
## 번역 작업 명세

- **지시**: 아래 명세에 따라 텍스트를 번역하고, 최종 결과물을 반드시 지정된 JSON 형식으로 반환하세요.
- **원본 텍스트**: The quick brown fox jumps over the lazy dog.
- **대상 언어**: 한국어
- **스타일 가이드**: 단순한 직역이 아닌, 운율과 비유가 살아있는 시적인 문체로 번역할 것.
- **출력 형식**:
  ```json
  {
    "original_text": "번역 전 원본 텍스트",
    "translated_text": "번역 후 결과물",
    "style": "적용된 스타일 (예: poetic)",
    "explanation": "스타일을 어떻게 적용했는지에 대한 설명"
  }
  ```
```
### 6.3.3 동적 설계 기법: 의도 확인 루프

때로는 사용자의 초기 요구사항이 모호하여 명확한 입/출력 명세를 미리 정의하기 어려울 수 있습니다. 이 경우, AI가 작업을 섣불리 시작하는 대신, 명세를 구체화하기 위해 사용자에게 질문하도록 만드는 '의도 확인 루프(Intent Clarification Loop)'를 설계할 수 있습니다.

> **예시: 번역 스타일이 모호할 때 '의도 확인 루프' 작동시키기**
>
> 1.  **사용자 지시:** "이 문장을 한국어로 번역해 줘: 'The quick brown fox jumps over the lazy dog.'"
> 2.  **AI의 확인 질문:** "알겠습니다. 번역을 진행하기 전에, 원하시는 번역 스타일을 알려주시겠어요? (예: 공식적인 톤, 친근한 구어체, 시적인 문체)"
> 3.  **사용자 답변:** "시적인 문체로 부탁해."
> 4.  **AI 작업 수행:** 명확해진 '시적인 문체'라는 요구사항에 맞춰 번역 작업을 수행합니다.

이처럼 AI를 '질문하는 조수'로 만들면, AI는 사용자와의 상호작용을 통해 스스로 작업의 명세를 완성하게 됩니다. 이는 재작업 비용을 줄이고 사용자의 만족도를 높이는 고급 설계 기법입니다.

## 7장으로 이어보기: 입출력에서 워크플로우로

이 장에서 설계한 명확한 입출력 명세는, 여러 에이전트가 협력하는 워크플로우를 구축하기 위한 가장 기본적인 전제 조건입니다.

다음 **[7장. 프로세스 설계: 협업 워크플로우 만들기](07-process-workflow.md)**에서는 이 구조화된 입출력을 [‘산출물 인터페이스’](glossary.md#산출물-인터페이스-artifact-interface)라는 에이전트 간의 공식적인 소통 규약으로 발전시키고, 이를 기반으로 복잡한 다중 에이전트 시스템을 설계하는 구체적인 방법을 배우게 됩니다.




## 실습 체크리스트
> 참고: 심화 과제는 [실습 과제 모음](practice-guide.md)을 참고하세요.

### 이 장을 완료하셨다면 다음을 확인하세요:

**개념 이해:**
- [ ] "Garbage In, Garbage Out" 원칙의 의미를 이해했다
- [ ] 입력 명세의 4가지 구성 요소(컨텍스트, 데이터, 전제조건, 도메인 지식)를 설명할 수 있다
- [ ] 출력 명세의 4가지 구성 요소(형식, 구조, 제약조건, 성공기준)를 설명할 수 있다
- [ ] 산출물 중심 접근법의 의미를 이해했다

**실습 능력:**
- [ ] JSON Schema를 사용하여 구조화된 출력 형식을 정의할 수 있다
- [ ] Few-shot 예시를 제공하여 AI가 패턴을 학습하게 할 수 있다
- [ ] 검증 가능한 성공 기준을 명시할 수 있다
- [ ] 의도 확인 루프를 설계하여 AI가 모호한 요구사항을 명확히 하게 할 수 있다

**적용 및 활용:**
- [ ] 원하는 출력을 먼저 정의하고 필요한 입력을 역으로 설계할 수 있다
- [ ] 비정형 출력을 구조화된 형식(JSON, YAML)으로 변환할 수 있다
- [ ] 입력 데이터를 전처리하여 품질을 향상시킬 수 있다

### 실습 과제

**과제 1: 출력 먼저 설계하기**

다음 작업에 대해 원하는 출력을 먼저 JSON 스키마로 정의하세요:

*작업:* "고객 티켓을 우선순위별로 분류하라"

1. 출력 JSON 구조 정의 (필수 필드: ticket_id, priority, category, urgency_score)
2. 각 필드의 데이터 타입 명시
3. 제약 조건 명시 (priority는 "high"/"medium"/"low", urgency_score는 1-10)

**과제 2: 입력 명세 설계**

과제 1에서 정의한 출력을 만들기 위해 필요한 입력 명세를 작성하세요:

```markdown
## 티켓 분류 작업 명세

### 컨텍스트 (Context)
- 목적: [고객 지원팀의 티켓 우선순위 결정]
- 대상 독자: [고객 지원 담당자]

### 데이터 (Data)
- 입력 형식: [JSON/CSV/텍스트]
- 필수 필드: [ticket_id, subject, description, created_at]
- 데이터 출처: [고객 지원 시스템]

### 전제 조건 (Pre-conditions)
- [예: 티켓은 24시간 이내 생성된 것만 대상]

### 도메인 지식 (Domain Knowledge)
- [예: "결제 오류"는 항상 high priority]

### 출력 형식
- [과제 1에서 정의한 JSON 스키마]
```

**과제 3: Few-shot 예시 작성**

과제 1-2에서 설계한 티켓 분류 작업에 대해 Few-shot 예시 2개를 작성하세요:

```markdown
## 예시 1
**입력:**
```json
{
  "ticket_id": "T-001",
  "subject": "결제가 안 됩니다",
  "description": "신용카드로 결제 시도 시 계속 오류가 발생합니다",
  "created_at": "2025-10-05T10:30:00Z"
}
```

**출력:**
```json
{
  "ticket_id": "T-001",
  "priority": "high",
  "category": "payment",
  "urgency_score": 9
}
```

## 예시 2
[유사하게 작성]
```

**과제 4: 의도 확인 루프 설계**

다음 모호한 요청에 대해 AI가 사용자에게 질문하도록 하는 인스트럭션을 작성하세요:

*사용자 요청:* "이 문서를 요약해줘"

```markdown
# 의도 확인 루프 인스트럭션

## 역할
당신은 요약 작업을 수행하기 전에 사용자의 의도를 명확히 하는 조수입니다.

## 처리 방법
1. 다음 정보가 모두 제공되었는지 확인:
   - [ ] 요약 대상 독자
   - [ ] 요약 길이/분량
   - [ ] 요약 목적/용도
   - [ ] 원하는 톤앤매너

2. 누락된 정보가 있다면, 작업을 시작하기 전에 반드시 질문:
   "요약을 진행하기 전에 다음 정보를 알려주시겠어요?
   - 이 요약을 읽을 대상은 누구인가요? (예: 경영진, 팀원, 고객)
   - 원하는 요약 길이는? (예: 3줄, 1페이지, 500자)
   - 요약의 주요 목적은? (예: 의사결정, 정보 공유, 참고)"

3. 모든 정보가 확인된 후에만 실제 요약 작업 수행
```

## 참고 자료

- Brown, T., et al. (2020). Language Models are Few-Shot Learners. arXiv:2005.14165. https://arxiv.org/abs/2005.14165
- JSON Schema. (2020). JSON Schema: A Media Type for Describing JSON Documents. https://json-schema.org/specification.html
- OpenAI. (2023). Function Calling and Structured Outputs. https://platform.openai.com/docs/guides/function-calling
- Anthropic. (2023). Tool Use (Function Calling). https://docs.anthropic.com/claude/docs/tool-use

---

[^1]: **Garbage In, Garbage Out (GIGO):** 컴퓨터 시스템에서 입력의 질이 출력의 질을 결정한다는 원칙. 아무리 뛰어난 시스템이라도, 부정확하거나 의미 없는 입력을 받으면 무의미한 출력을 내놓을 수밖에 없다는 의미를 담고 있다.

[^2]: **JSON Schema:** JSON 데이터의 구조를 정의하고 검증하기 위한 표준 규격. 데이터의 필수 필드, 타입, 형식, 제약 조건 등을 명시할 수 있어, 시스템 간 데이터 교환의 안정성을 높이는 데 사용된다.

[^3]: **퓨샷(Few-shot) 프롬프팅:** 대규모 언어 모델(LLM)에게 별도의 학습 없이, 몇 개(few)의 예시(shots)만으로 새로운 작업을 수행하도록 유도하는 기술. 모델이 예시의 패턴을 파악하여 유사한 작업을 처리하게 하는 방식이다. 예: "사과→apple, 바나나→banana"라는 예시만으로 "오렌지→?"를 "orange"로 번역.

[^4]: **파싱(Parsing):** 컴퓨터가 데이터의 구조를 분석하여 의미 있는 정보로 변환하는 과정. 예: JSON 문자열을 읽어 객체로 변환하거나, CSV 파일을 읽어 표 형식의 데이터로 변환하는 것.

---

## Part 2 완료: 체계적인 인스트럭션 설계를 마스터했습니다

축하합니다! **Part 2: 설계 원칙과 구성 요소**의 모든 장을 학습하셨습니다. 이제 다음 내용을 마스터하셨습니다:

- **4장 - 메타 원칙**: SSOT, SoC, MECE로 인스트럭션의 논리적 구조 설계
- **5장 - 에이전트와 제약**: 명확한 역할과 한계 설정으로 예측 가능한 AI 행동 유도
- **6장 - 입출력 설계**: 구조화된 데이터 명세로 일관된 결과물 확보

### 학습 성과 체크

다음 내용을 확인하고 다음 Part로 넘어가세요:

- [ ] **설계 원칙 적용**: SSOT, SoC, MECE 원칙을 인스트럭션에 적용하여 중복을 제거하고 책임을 분리할 수 있다
- [ ] **역할 기반 설계**: AI의 역할(Role)과 제약(Constraint)을 명확히 정의하여 작업 범위를 제어할 수 있다
- [ ] **명세 작성 능력**: JSON Schema로 입출력 형식을 정의하고, Few-shot 예시로 품질을 향상시킬 수 있다
- [ ] **의도 확인 루프**: 모호한 요구사항을 AI가 질문으로 명확히 하게 만드는 동적 설계 기법을 활용할 수 있다

---

## 다음: Part 3 - 워크플로우, 성능과 평가

이제 **Part 3**에서는 설계한 인스트럭션을 **실제 워크플로우로 연결**하고 **성능을 최적화**하는 방법을 배웁니다:

- **7장 - 프로세스와 워크플로우**: 여러 에이전트가 협력하는 복잡한 작업 흐름 설계하기
- **8장 - 성능 최적화**: 토큰 사용량, 응답 속도, 비용을 줄이는 실용적인 기법들
- **9장 - 평가와 검증**: 인스트럭션의 품질을 객관적으로 측정하고 지속적으로 개선하기

**Part 2에서 개별 인스트럭션을 체계적으로 설계했다면, Part 3에서는 그것들을 연결하여 실제 업무에 적용하고 최적화하는 방법을 배웁니다.** 단일 에이전트의 한계를 넘어, 복잡한 문제를 해결하는 다중 에이전트 시스템을 구축하게 됩니다.

**준비되셨다면, [7장: 프로세스 설계와 워크플로우](07-process-workflow.md)로 시작하세요!**
