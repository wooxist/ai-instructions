# 6장. 입력과 출력 설계

**Part 2: 인스트럭션 시스템 설계와 평가**

**목적:** AI에게 전달할 데이터(입력)와 받아야 할 결과물(출력)의 명확한 입·출력 명세를 설계하여, 예측 가능하고 일관된 결과물을 얻는 방법을 배웁니다.

### 이 장에서 배우는 것
- 입력과 출력 설계가 왜 중요한지 이해합니다. (Garbage In, Garbage Out)
- 입력과 출력을 명세화하는 구체적인 구성 요소를 배웁니다.
- 산출물 중심 원칙에 기반한 입력/출력 설계 기법(구조화, Few-shot 등)을 익힙니다.
- 사용자의 의도가 모호할 때 AI가 동적으로 명세를 구체화하는 '의도 확인 루프'를 배웁니다.

## 6.1 왜 입력과 출력 설계가 중요한가?

5장에서 우리는 복잡한 문제를 해결하기 위해 단일 책임을 가진 전문가 에이전트들을 설계하는 법을 배웠습니다. 하지만 아무리 뛰어난 전문가라도, 작업에 필요한 '재료(입력)'가 잘못되거나 만들어야 할 '완성품(출력)'에 대한 정의가 모호하다면 제대로 된 결과물을 낼 수 없습니다. 입력과 출력 설계는 바로 이 '재료'와 '완성품'에 대한 명확한 약속, 즉 **명세(Specification)**를 만드는 과정입니다.

### 6.1.1 "Garbage In, Garbage Out": 모호한 입력의 함정

컴퓨터 과학의 오랜 격언인 "쓰레기를 넣으면 쓰레기가 나온다(Garbage In, Garbage Out)[^1]"는 AI 시대에 더욱 중요해졌습니다. AI에게 모호하거나 잘못된 입력을 주면 다음과 같은 문제가 발생합니다.

- **잘못된 가정:** AI는 컨텍스트가 부족하면 스스로 가정을 만들어냅니다. "보고서를 요약해줘"라는 지시에 대상 독자를 명시하지 않으면, AI는 독자를 기술 전문가로 가정하고 어려운 용어로 가득 찬 요약문을 만들 수 있습니다.
- **잘못된 데이터 작업:** 사용해야 할 데이터의 출처나 범위를 명확히 하지 않으면, AI는 엉뚱한 데이터를 분석하거나 오래된 정보를 사용하여 사실과 다른 결과를 도출할 수 있습니다.
- **낮은 품질의 결과:** 입력 데이터에 노이즈가 많거나 정제되지 않은 상태라면, AI는 그 노이즈까지 학습하여 결과물의 품질이 저하됩니다.

### 6.1.2 예측 불가능한 출력의 문제

출력에 대한 명확한 명세가 없다면, AI는 자유롭게 결과를 '창작'합니다. 이는 창의적인 아이디어를 얻을 때는 유용할 수 있지만, 여러 에이전트가 협력하는 자동화 시스템을 구축할 때는 심각한 문제를 야기합니다.

- **일관성 부재:** 동일한 작업을 요청해도 매번 다른 형식(줄글, 목록, 표 등)과 다른 구조로 결과물을 생성하여, 결과의 일관성을 보장할 수 없습니다.
- **후속 처리의 어려움:** 한 에이전트의 출력을 다른 에이전트의 입력으로 사용해야 하는 워크플로우에서, 출력 형식이 비정형적이면 후속 에이전트가 정보를 파싱(parsing)하고 처리하는 데 실패하게 됩니다. 이는 전체 자동화 시스템의 중단으로 이어집니다.
- **검증의 어려움:** 정해진 형식이 없으면 결과물이 요구사항을 충족했는지 자동으로 검증하기가 매우 어렵습니다.

## 6.2 무엇을 설계해야 하는가?: 입력과 출력의 명세화

이러한 문제를 해결하기 위해, 우리는 에이전트가 상호작용할 데이터와 결과물에 대한 명확한 '명세(Specification)'를 설계해야 합니다. 이는 에이전트의 행동을 제어하는 가장 확실한 방법입니다.

### 6.2.1 입력 명세(Input Specification)

입력 명세는 AI에게 제공할 '재료'의 목록과 사양을 정의하는 것입니다.

- **컨텍스트 (Context):** 작업의 최종 목표, 결과물의 예상 독자, 관련 배경 정보 등 작업의 맥락을 제공합니다.
- **데이터 (Data):** AI가 사용해야 할 데이터의 출처(파일, URL, API 등), 형식(텍스트, JSON, CSV 등), 그리고 데이터의 스키마(필드, 타입 등)를 명확히 지정합니다.
- **전제 조건 (Pre-conditions):** "이 분석은 지난달 유료 사용자만을 대상으로 한다"와 같이, 작업이 수행되어야 할 기본 가정이나 범위를 명시합니다.
- **도메인 지식 (Domain Knowledge):** 특정 전문 분야의 작업을 수행할 때, AI가 참고해야 할 용어집, 핵심 개념, 관련 문서 등을 제공하여 품질을 높입니다.

### 6.2.2 출력 명세(Output Specification)

출력 명세는 AI가 만들어내야 할 '완성품'의 모습을 구체적으로 정의하는 것입니다.

- **형식 (Format):** JSON, YAML, 마크다운 표, 불릿 리스트 등 기계가 처리하기 쉽거나(machine-readable) 사람이 읽기 쉬운(human-readable) 형식을 지정합니다.
- **구조 (Structure):** 출력물에 포함되어야 할 필수 항목, 각 항목의 데이터 타입, 그리고 항목들의 순서 등을 스키마(Schema)로 정의합니다.
- **제약 조건 (Constraints):** "요약은 200단어 미만", "톤앤매너는 공식적이고 정중하게" 등 결과물이 지켜야 할 추가적인 규칙을 명시합니다.
- **성공 기준 (Success Criteria):** "주요 불만사항 3가지를 반드시 포함해야 한다"와 같이, 어떤 결과물이 '좋은 결과물'인지를 판단할 수 있는 기준을 제공합니다.

## 6.3 어떻게 설계하는가?: 결과물 중심 접근법과 구체적 기법

효과적인 입력과 출력 설계는 4장의 **산출물 중심(Output-Driven)** 원칙을 따릅니다. 즉, 최종적으로 얻고 싶은 '출력'을 먼저 명확하게 정의하고, 그 출력을 만드는 데 필요한 '입력'을 역으로 설계하는 것이 가장 효율적입니다.

### 6.3.1 출력 설계 기법

- **구조화된 형식 강제:** 가장 기본적이면서 강력한 기법입니다. 이는 마치 회사에서 보고서를 제출할 때 정해진 양식(템플릿)에 맞춰 작성하도록 하는 것과 같습니다. AI가 자유롭게 서술하게 두는 대신, `JSON`이나 `YAML`과 같은 구조화된 형식으로 답변하도록 강제하면, 기계가 그 결과를 자동으로 처리하기 매우 쉬워집니다. 특히 JSON Schema[^2]를 함께 제공하면, AI는 스키마에 정의된 필드와 데이터 타입에 맞춰 정확하게 결과물을 생성합니다. 이는 에이전트 간의 데이터 교환 시 안정성을 보장하는 핵심입니다.
- **Few-Shot 예시 제공:** 백 마디 설명보다 한두 개의 좋은 예시가 더 효과적일 수 있습니다. 인스트럭션 내에 우리가 원하는 결과물의 구체적인 예시(입력-출력 쌍)를 1~2개 포함하면, AI는 그 패턴을 학습하여 유사한 형태로 결과물을 생성합니다. 이를 '퓨샷(Few-shot) 프롬프팅'[^3]이라고 합니다.
- **성공 기준 및 평가 지표 명시:** "이 요약문의 품질은 다음 3가지 기준으로 평가됩니다: 1) 핵심 내용 포함 여부, 2) 300단어 미만, 3) 중학생도 이해할 수 있는 평이한 언어 사용."과 같이 평가 기준을 명시하면, AI는 스스로 결과물을 개선하며 기준을 맞추려고 노력합니다.

> **예시: [1단계] 원하는 번역 결과물(출력)을 먼저 정의하기**
>
> 단순한 번역문(string) 대신, 작업의 메타데이터를 포함하는 JSON 객체로 결과물을 받도록 먼저 명확히 정의합니다.
>
> ```json
> {
>   "original_text": "The quick brown fox jumps over the lazy dog.",
>   "translated_text": "날쌘 갈색 여우가 게으른 개를 뛰어넘는다.",
>   "style": "poetic",
>   "explanation": "운율감을 살리기 위해 '날쌘'과 같은 형용사를 사용하고, 전체적으로 생동감 있는 어조를 유지했습니다."
> }
> ```
> 이렇게 원하는 출력 형식을 먼저 정의하면, 다음 단계에서 어떤 입력이 필요한지 명확해집니다.

### 6.3.2 입력 설계 기법

- **체계적인 컨텍스트 제공:** 컨텍스트를 단순히 나열하기보다, `## 최종 목표`, `## 대상 독자`, `## 참고 자료` 와 같이 마크다운 헤더를 사용해 구조적으로 제공하면, AI는 각 정보의 역할을 더 명확하게 파악합니다.
- **데이터 전처리 및 정제:** AI에게 데이터를 전달하기 전에, 관련 없는 정보를 제거하거나 노이즈를 줄이는 전처리 과정을 거치는 것이 좋습니다. 이는 AI가 작업의 핵심에 더 집중하고, 적은 토큰으로 더 높은 품질의 결과를 얻게 해줍니다.

> **예시: [2단계] 정의된 출력을 만들기 위한 입력 설계하기**
>
> **나쁜 입력:** "이 문장 번역해줘: 'The quick brown fox jumps over the lazy dog.' 대상 언어는 한국어야. 좀 더 시적으로." (→ 어떤 결과가 나올지 예측하기 어렵고, 후속 처리가 불가능합니다.)
>
> **좋은 입력:** 6.3.1에서 정의한 JSON 출력을 생성하도록, 모든 요구사항을 구조화하여 명확히 지시합니다.
>
> ```markdown
> ## 번역 작업 명세
>
> - **지시**: 아래 명세에 따라 텍스트를 번역하고, 최종 결과물을 반드시 지정된 JSON 형식으로 반환하세요.
> - **원본 텍스트**: The quick brown fox jumps over the lazy dog.
> - **대상 언어**: 한국어
> - **스타일 가이드**: 단순한 직역이 아닌, 운율과 비유가 살아있는 시적인 문체로 번역할 것.
> - **출력 형식**:
>   ```json
>   {
>     "original_text": "번역 전 원본 텍스트",
>     "translated_text": "번역 후 결과물",
>     "style": "적용된 스타일 (예: poetic)",
>     "explanation": "스타일을 어떻게 적용했는지에 대한 설명"
>   }
>   ```
> ```

### 6.3.3 동적 설계 기법: 의도 확인 루프

때로는 사용자의 초기 요구사항이 모호하여 명확한 입/출력 명세를 미리 정의하기 어려울 수 있습니다. 이 경우, AI가 작업을 섣불리 시작하는 대신, 명세를 구체화하기 위해 사용자에게 질문하도록 만드는 '의도 확인 루프(Intent Clarification Loop)'를 설계할 수 있습니다.

> **예시: 번역 스타일이 모호할 때 '의도 확인 루프' 작동시키기**
>
> 1.  **사용자 지시:** "이 문장을 한국어로 번역해 줘: 'The quick brown fox jumps over the lazy dog.'"
> 2.  **AI의 확인 질문:** "알겠습니다. 번역을 진행하기 전에, 원하시는 번역 스타일을 알려주시겠어요? (예: 공식적인 톤, 친근한 구어체, 시적인 문체)"
> 3.  **사용자 답변:** "시적인 문체로 부탁해."
> 4.  **AI 작업 수행:** 명확해진 '시적인 문체'라는 요구사항에 맞춰 번역 작업을 수행합니다.

이처럼 AI를 '질문하는 조수'로 만들면, AI는 사용자와의 상호작용을 통해 스스로 작업의 명세를 완성하게 됩니다. 이는 재작업 비용을 줄이고 사용자의 만족도를 높이는 고급 설계 기법입니다.

## 실무 예제로 이어보기

이 장에서 배운 개념들을 종합하여 실제 파일 기반 인스트럭션 시스템으로 구축하는 전체 과정은 [10장. 상황별 인스트럭션 설계 패턴 예제](10-1-single-agent-patterns.md)에서 자세히 다룹니다.

## 참고 자료

- Brown, T., et al. (2020). Language Models are Few-Shot Learners. *arXiv preprint arXiv:2005.14165*.
- JSON Schema. (2020). JSON Schema: A Media Type for Describing JSON Documents. https://json-schema.org/specification.html
- OpenAI. (2023). Function Calling and Structured Outputs. https://platform.openai.com/docs/guides/function-calling
- Anthropic. (2023). Tool Use (Function Calling). https://docs.anthropic.com/claude/docs/tool-use

---

[^1]: **Garbage In, Garbage Out (GIGO):** 컴퓨터 시스템에서 입력의 질이 출력의 질을 결정한다는 원칙. 아무리 뛰어난 시스템이라도, 부정확하거나 의미 없는 입력을 받으면 무의미한 출력을 내놓을 수밖에 없다는 의미를 담고 있다.

[^2]: **JSON Schema:** JSON 데이터의 구조를 정의하고 검증하기 위한 표준 규격. 데이터의 필수 필드, 타입, 형식, 제약 조건 등을 명시할 수 있어, 시스템 간 데이터 교환의 안정성을 높이는 데 사용된다.

[^3]: **퓨샷(Few-shot) 프롬프팅:** 대규모 언어 모델(LLM)에게 별도의 학습 없이, 몇 개(few)의 예시(shots)만으로 새로운 작업을 수행하도록 유도하는 기술. 모델이 예시의 패턴을 파악하여 유사한 작업을 처리하게 하는 방식이다. 예: "사과→apple, 바나나→banana"라는 예시만으로 "오렌지→?"를 "orange"로 번역.

[^4]: **파싱(Parsing):** 컴퓨터가 데이터의 구조를 분석하여 의미 있는 정보로 변환하는 과정. 예: JSON 문자열을 읽어 객체로 변환하거나, CSV 파일을 읽어 표 형식의 데이터로 변환하는 것.
