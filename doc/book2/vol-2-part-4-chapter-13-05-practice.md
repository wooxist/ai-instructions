## 13.5 실습 과제

이 장에서 배운 파일 시스템 구현을 실제로 적용해보는 실습입니다.

### 기본 실습

#### 실습 1: 파일 시스템 구조 설계

**목표**: 사고 클러스터를 파일 시스템으로 매핑합니다.

**과제**:
1. 11장이나 12장에서 만든 사고 클러스터 1개를 선택하세요
2. 파일 시스템 구조를 설계하세요:
   - `/thinking/` 디렉토리 (Stage별 하위 디렉토리)
   - `/drafts/` 디렉토리
   - `/outputs/` 디렉토리
   - `/shared/` 디렉토리 (필요시)
3. 각 Stage의 산출물이 어느 파일에 저장될지 매핑하세요
4. thinking_state.json 템플릿을 작성하세요
5. 실제로 디렉토리를 생성하세요 (VS Code나 터미널 사용)

**평가 기준**:
- 3가지 원칙(격리, 공유, 명명) 준수했는가?
- 각 Stage의 산출물이 파일로 표현되는가?
- 사고 흐름을 파일로 추적 가능한가?

**제출 형식**: 
- 디렉토리 구조 다이어그램
- thinking_state.json 템플릿
- 실제 생성한 디렉토리 스크린샷

**예상 소요 시간**: 2시간

---

#### 실습 2: 사고 기록 작성

**목표**: thinking_record.json 파일을 작성합니다.

**과제**:
1. 실습 1의 파일 시스템 사용
2. Stage 1(Planning)의 thinking_record.json을 작성하세요:
   - metadata: cluster_id, stage, timestamps
   - process: 활동, 도구, 주요 결정사항
   - output: ideas 타입 (최소 3개 아이디어)
   - quality: 4가지 지표 (완전성, 일관성, 실행가능성, 정렬성)
3. Stage 2-4도 동일하게 작성하세요
4. thinking_state.json에 전체 진행 상황을 기록하세요
5. Stage 전환 시 이전 Stage 참조를 명시하세요

**평가 기준**:
- JSON 형식이 올바른가?
- 사고 과정이 재현 가능하게 기록되었는가?
- 파일 간 참조(references)가 명확한가?
- 진행 상황을 한눈에 파악 가능한가?

**제출 형식**:
- Stage별 thinking_record.json (4개)
- thinking_state.json (1개)
- 간단한 설명 문서

**예상 소요 시간**: 2-3시간

---

#### 실습 3: 피드백 루프 구현

**목표**: 실행 결과를 파일로 수집하고 사고 개선에 활용합니다.

**과제**:
1. 실습 1-2의 사고 클러스터를 실제로 2주간 실행하세요
2. 피드백 데이터를 수집하세요:
   - 매일 `/feedback/daily_YYYY-MM-DD.json` 파일 생성
   - 결과 메트릭 기록 (예: 조회수, 반응, 소요 시간)
   - 사용자 피드백 기록
3. 2주 후 패턴을 분석하세요:
   - 어떤 Stage에서 시간이 오래 걸렸나?
   - 품질 점수가 낮은 Stage는?
   - 반복되는 문제는?
4. 개선 사항을 도출하세요:
   - `/thinking/improvements.json` 파일 작성
   - 각 Stage별 개선 제안
   - 다음 사이클에 적용할 변경 사항
5. 다음 실행에 개선 사항을 반영하세요

**평가 기준**:
- 결과 데이터가 체계적으로 수집되었는가?
- 분석에서 의미있는 인사이트가 도출되었는가?
- 개선 사항이 구체적이고 실행 가능한가?
- 실제로 다음 사이클에 반영되었는가?

**제출 형식**:
- 2주간의 피드백 파일들
- 분석 보고서 (patterns_analysis.md)
- improvements.json
- 개선 적용 전후 비교 문서

**예상 소요 시간**: 2주 + 분석 3시간

---

### 심화 실습

#### 실습 4: Git을 활용한 사고 버전 관리

**목표**: Git으로 사고 과정을 버전 관리하고 협업합니다.

**과제**:
1. 실습 1-2의 파일 시스템을 Git 저장소로 초기화
2. `.gitignore` 설정:
   - 민감 정보 제외 (개인 정보, API 키 등)
   - 임시 파일 제외
3. Commit 메시지 규칙 정의:
   - 형식: `[Stage명] 작업 내용`
   - 예: `[planning] 10개 아이디어 브레인스토밍 완료`
4. 브랜치 전략 구현:
   - `main`: 승인된 최종 버전
   - `feature/planning`, `feature/reasoning` 등: Stage별 작업
5. Pull Request로 사고 검토:
   - Stage 완료 시 PR 생성
   - 팀원 검토 + 코멘트
   - 승인 후 main에 머지
6. 사고 히스토리 추적:
   - `git log`로 사고 변천 과정 확인
   - 특정 시점으로 돌아가 과거 사고 재현

**평가 기준**:
- Git 저장소가 올바르게 설정되었는가?
- Commit history가 의미있는 메시지를 가지는가?
- 브랜치 전략이 효과적으로 적용되었는가?
- 협업 프로세스(PR, 리뷰)가 작동하는가?

**제출 형식**:
- Git repository (GitHub/GitLab)
- Commit history
- 브랜치 구조 다이어그램
- 협업 가이드 문서

**예상 소요 시간**: 4시간

---

#### 실습 5: 자동화 스크립트 개발

**목표**: 파일 생성, 상태 추적, 리포팅을 자동화합니다.

**과제**:
1. Python으로 4개의 자동화 스크립트 개발:

**스크립트 1: init_task.py**
```python
# 새 사고 클러스터 디렉토리 자동 생성
# 입력: cluster_id, cluster_name
# 출력: /thinking_clusters/TC{id}_{name}/ 전체 구조
```

**스크립트 2: update_state.py**
```python
# thinking_state.json 자동 업데이트
# 입력: stage, status
# 출력: 업데이트된 thinking_state.json
```

**스크립트 3: generate_report.py**
```python
# 진행 상황 HTML 리포트 생성
# 입력: thinking_state.json
# 출력: progress_report.html (진행률, 품질 차트 등)
```

**스크립트 4: collect_feedback.py**
```python
# 피드백 데이터 자동 수집 및 통합
# 입력: /feedback/*.json
# 출력: feedback_summary.json (통계, 패턴)
```

2. 각 스크립트에 대해:
   - 명확한 함수 구조
   - 에러 처리
   - 사용 예시 (docstring)
   - 단위 테스트 (선택)

3. 통합 사용 시나리오:
   - 새 클러스터 시작: `init_task.py`
   - Stage 완료: `update_state.py`
   - 주간 리포트: `generate_report.py`
   - 월간 분석: `collect_feedback.py`

**평가 기준**:
- 모든 스크립트가 정상 작동하는가?
- 에러 처리가 적절한가?
- 사용 가이드가 명확한가?
- 실제 업무에 즉시 활용 가능한가?

**제출 형식**:
- 4개 Python 스크립트
- 사용 가이드 (README.md)
- 실행 예시 (스크린샷 또는 비디오)
- 예시 출력 파일들

**예상 소요 시간**: 1주 (각 스크립트당 1-2일)

---

### 자가 평가

다음 질문에 답하며 이해도를 점검하세요:

1. **파일 시스템의 3가지 핵심 가치는 무엇인가요?**
   - 영속성
   - 공유성
   - 추적성

2. **thinking_state.json의 역할은 무엇인가요?**
   - 사고 클러스터의 진행 상황 추적
   - 현재 어느 Stage인지 표시
   - 각 Stage의 상태 관리

3. **사고 기록(thinking_record)과 산출물(output)의 차이는?**
   - 사고 기록: 어떻게 생각했는가 (과정)
   - 산출물: 무엇을 만들었는가 (결과)

4. **피드백 루프를 파일로 어떻게 구현하나요?**
   - `/feedback/` 디렉토리에 결과 데이터 저장
   - 패턴 분석 후 `/thinking/improvements.json` 작성
   - 다음 실행에 개선 사항 반영

5. **Git으로 사고를 버전 관리하는 이점은?**
   - 사고 변천 과정 추적
   - 과거 시점으로 되돌리기
   - 팀 협업 및 리뷰

**적용 수준 체크**:
- [ ] 레벨 1 (기초): 디렉토리 구조를 설계하고 파일 생성 가능
- [ ] 레벨 2 (중급): 사고 과정을 JSON으로 기록하고 추적 가능
- [ ] 레벨 3 (고급): 피드백 루프를 파일 기반으로 구현 가능
- [ ] 레벨 4 (전문가): 자동화 도구를 개발하고 팀에 배포 가능

---

**다음 장**: 14장에서는 11-12-13장의 모든 내용을 통합하여 **완전한 실전 사례**를 다룹니다. 사고 클러스터 설계부터 파일 시스템 구현까지 end-to-end 워크플로우를 경험합니다.
