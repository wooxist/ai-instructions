# Part 1: 단일 프롬프트 단계 (1-4장)

**학습 범위**: AI 협업 가이드북 1-4장
**난이도**: ★☆☆ (기본)
**예상 소요**: 2-3시간

---

## 🎯 학습 목표

### 이 Part에서 배우는 것
1. **좋은 프롬프트 작성법** (1장)
   - 명확한 요청, 제약사항, 출력 형식 지정
   - 나쁜 프롬프트 → 좋은 프롬프트 개선
   
2. **질문 설계 전략** (2장)
   - 폐쇄형/개방형/비교형 질문 활용
   - 상황에 맞는 질문 유형 선택

3. **인스트럭션 구조화** (3장)
   - 8가지 구성 요소 (역할/목표/입력/출력/제약/처리/성공기준/톤)
   - 재사용 가능한 표준 인스트럭션

4. **메타 원칙 적용** (4장)
   - SSOT (Single Source of Truth): 중복 제거
   - SoC (Separation of Concerns): 관심사 분리

---

## 📱 TaskFlow 시나리오 (Part 1)

**상황**: TaskFlow 앱 개발 초기 단계
- 기획서 작성 필요
- 화면 구성 아이디어 필요
- 기능 목록 정리 필요

**접근법**: AI에게 **한 번의 대화**로 각 작업 요청
- 구조화되지 않음
- 재사용 어려움
- 일관성 보장 안 됨

**한계**:
- ❌ 복잡한 작업은 한 번에 처리 어려움
- ❌ 여러 번 요청 시 일관성 떨어짐
- ❌ 템플릿화/재사용 불가

---

## 📝 예제 모음

### 1. 기획 프롬프트 (`01-planning.md`)

**나쁜 프롬프트 예시**:
```
할일 관리 앱 기획서 써줘
```

**문제점**:
- 너무 모호함
- 출력 형식 불명확
- 필요한 정보 누락
- 대상 독자 불명확

**좋은 프롬프트 예시** (1-4장 학습 적용):
```markdown
# 역할
당신은 5년 경력의 제품 기획자입니다.

# 목표
"TaskFlow" 앱의 MVP 기획서를 작성합니다.
- 앱 개념 및 핵심 가치
- 타겟 사용자
- 핵심 기능 (3-5개)
- 화면 구성 (5개 이하)

# 제약사항
- MVP 범위: 개발 기간 2개월 이내
- 타겟: 개인 사용자 (팀 기능은 제외)
- 플랫폼: 웹 우선 (모바일 앱은 향후)
- 기술 스택: React + Node.js

# 출력 형식
다음 구조로 Markdown 문서 작성:

## 1. 앱 개념
- 한 줄 설명
- 핵심 가치 제안 (3가지)

## 2. 타겟 사용자
- 주 사용자 페르소나 (1명)
- 사용 시나리오 (2-3개)

## 3. 핵심 기능
| 기능명 | 설명 | 우선순위 |
|--------|------|----------|
| ...    | ...  | P0/P1/P2 |

## 4. 화면 구성
- 화면명 (간단한 설명)
- 화면 간 이동 흐름도 (텍스트로)

## 5. 성공 지표
- 출시 후 3개월 내 목표 (2-3개)

# 톤앤매너
- 간결하고 실용적
- 개발팀이 바로 이해할 수 있는 수준
- 마케팅 용어 지양, 기술적 실현 가능성 중시
```

**개선 포인트**:
- ✅ 역할 명확 (5년 경력 기획자)
- ✅ 구체적 목표 (MVP 기획서, 3-5개 기능)
- ✅ 제약사항 명시 (2개월, 개인용, 웹)
- ✅ 출력 형식 상세 (Markdown 구조)
- ✅ 톤앤매너 정의 (간결, 실용적)

---

### 2. 디자인 프롬프트 (`02-design.md`)

**질문 유형별 활용** (2장 학습):

**A. 폐쇄형 질문** - 명확한 답변 필요
```
TaskFlow의 메인 컬러는 다음 중 무엇이 적합한가?
1. 차분한 블루 (#4A90E2)
2. 활기찬 오렌지 (#FF9500)
3. 집중의 그린 (#34C759)

선택 이유를 3줄로 설명하시오.
```

**B. 개방형 질문** - 창의적 아이디어
```
TaskFlow 앱에서 "할일 완료"를 축하하는 
창의적인 UX 아이디어 3가지를 제안해주세요.

각 아이디어는:
- 아이디어명
- 작동 방식 (2-3문장)
- 기대 효과
- 구현 난이도 (쉬움/보통/어려움)
```

**C. 비교형 질문** - 의사결정 지원
```
TaskFlow의 할일 목록 레이아웃을 결정해야 합니다.
다음 두 옵션을 비교 분석해주세요:

옵션 A: 카드형 레이아웃
- 각 할일이 카드 형태
- 넓은 공간, 시각적 여백

옵션 B: 리스트형 레이아웃
- 각 할일이 한 줄
- 밀도 높음, 한눈에 많이 보임

비교 기준:
| 기준 | 옵션 A | 옵션 B | 추천 |
|------|--------|--------|------|
| 가독성 | | | |
| 정보 밀도 | | | |
| 모바일 적합성 | | | |
| 구현 복잡도 | | | |

최종 추천과 이유 (3줄):
```

---

### 3. 개발 프롬프트 (`03-development.md`)

**8가지 구성 요소 활용** (3장 학습):

```markdown
# 1. 역할 (Role)
당신은 React/Node.js 풀스택 개발자입니다.

# 2. 목표 (Goal)
TaskFlow의 "할일 목록 표시" 기능을 구현합니다.

# 3. 입력 (Input)
- API 엔드포인트: GET /api/tasks
- 응답 형식: 
  ```json
  {
    "tasks": [
      {
        "id": "string",
        "title": "string",
        "priority": "high|medium|low",
        "dueDate": "ISO 8601",
        "completed": boolean
      }
    ]
  }
  ```

# 4. 출력 (Output)
React 컴포넌트 코드 (TaskList.jsx)
- 프롭스, 상태 관리, 렌더링 로직 포함
- 주석으로 주요 로직 설명

# 5. 제약사항 (Constraints)
- React Hooks 사용 (함수형 컴포넌트)
- 외부 UI 라이브러리 없이 순수 CSS
- 접근성 고려 (ARIA 속성)
- 로딩/에러 상태 처리 필수

# 6. 처리 단계 (Process)
1. 컴포넌트 구조 설계
2. API 호출 로직 (useEffect)
3. 상태 관리 (useState)
4. 렌더링 로직
5. CSS 스타일링

# 7. 성공 기준 (Success Criteria)
- [ ] tasks 배열이 화면에 표시됨
- [ ] 우선순위별 색상 구분
- [ ] 완료된 할일은 취소선
- [ ] 로딩 중 스피너 표시
- [ ] 에러 시 사용자 친화적 메시지

# 8. 톤앤매너 (Tone)
- 코드는 간결하고 읽기 쉽게
- 주석은 "왜"를 설명 (무엇이 아닌)
- 베스트 프랙티스 따름
```

**메타 원칙 적용 예시** (4장 학습):

**SSOT 적용**:
```markdown
# shared-config.md (공통 설정)

## API 기본 정보
- Base URL: https://api.taskflow.app
- 인증: Bearer Token
- 타임아웃: 30초

## 데이터 모델

### Task
```json
{
  "id": "string (UUID)",
  "title": "string (max 200자)",
  "priority": "high | medium | low",
  "dueDate": "ISO 8601 (nullable)",
  "completed": boolean,
  "createdAt": "ISO 8601",
  "updatedAt": "ISO 8601"
}
```

**모든 프롬프트는 이 파일을 참조합니다**:
"작업 시 `/shared-config.md`의 데이터 모델을 사용하세요."
```

**SoC 적용**:
```markdown
# 관심사별 분리

1. 데이터 관리 프롬프트
   - API 호출
   - 상태 관리
   - 데이터 변환

2. UI 렌더링 프롬프트
   - 컴포넌트 구조
   - 스타일링
   - 접근성

3. 비즈니스 로직 프롬프트
   - 우선순위 계산
   - 마감일 알림
   - 필터링/정렬
```

---

## ✅ 실습 체크리스트 (`checklist.md`)

### 1장: 프롬프트 기초
- [ ] 나쁜 프롬프트 1개 작성
- [ ] 좋은 프롬프트로 개선 (5가지 요소 포함)
- [ ] 결과 비교 및 차이점 기록

### 2장: 질문 설계
- [ ] 폐쇄형 질문 작성 및 실행
- [ ] 개방형 질문 작성 및 실행
- [ ] 비교형 질문 작성 및 실행
- [ ] 각 유형의 장단점 정리

### 3장: 인스트럭션 구조
- [ ] 8가지 구성 요소 모두 포함한 프롬프트 작성
- [ ] AI에게 실행 및 결과 검증
- [ ] 누락 시 발생하는 문제 경험

### 4장: 메타 원칙
- [ ] shared-config.md 작성 (공통 설정/모델)
- [ ] 2개 이상 프롬프트에서 참조
- [ ] 중복 제거 효과 측정

---

## 🚨 Part 1의 한계점

실습 중 다음 한계를 경험하게 됩니다:

### 1. 복잡도 한계
- ❌ "전체 앱을 설계해줘" → 너무 크면 실패
- ❌ 여러 단계가 필요한 작업 → 한 번에 불가능

### 2. 일관성 문제
- ❌ 같은 프롬프트, 다른 결과
- ❌ 이전 대화 맥락 손실
- ❌ 용어/스타일 불일치

### 3. 재사용성 부족
- ❌ 프롬프트를 템플릿화하기 어려움
- ❌ 프로젝트 간 재사용 제한적

### 4. 협업 불가
- ❌ 여러 사람이 같이 작업 어려움
- ❌ 버전 관리 불가능

**→ 이런 한계를 해결하기 위해 Part 2로 진화합니다!**

---

## 📚 다음 단계

Part 1을 완료했다면:
1. 체크리스트 모두 완료했는지 확인
2. 한계점을 직접 경험했는지 확인
3. **Part 2 (단일 에이전트)**로 진행
   - 재사용 가능한 에이전트 설계
   - 명확한 입출력 인터페이스
   - 단계별 워크플로우

**디렉토리**: `../part2-single-agent/`

---

## 🔗 참고 자료

- **가이드북 1장**: `/book/01-introduction.md`
- **가이드북 2장**: `/book/02-questions.md`
- **가이드북 3장**: `/book/03-good-instructions.md`
- **가이드북 4장**: `/book/04-meta-principles.md`
- **실습 가이드**: `/book/practice-guide.md`

---

**예상 학습 시간**: 2-3시간
**완료 후 자가 평가**: 체크리스트 100% + 한계점 경험
